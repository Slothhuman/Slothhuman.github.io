<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>JVM on Slothhuman&#39;s Blog</title>
        <link>https://slothhuman.github.io/tags/jvm/</link>
        <description>Recent content in JVM on Slothhuman&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sat, 28 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://slothhuman.github.io/tags/jvm/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>JVM（四）Java的自动内存管理</title>
        <link>https://slothhuman.github.io/p/jvm%E5%9B%9Bjava%E7%9A%84%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <pubDate>Sat, 28 Jan 2023 00:00:00 +0000</pubDate>
        
        <guid>https://slothhuman.github.io/p/jvm%E5%9B%9Bjava%E7%9A%84%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        <description>&lt;img src="https://slothhuman.github.io/img/14.jpg" alt="Featured image of post JVM（四）Java的自动内存管理" /&gt;&lt;h2 id=&#34;java的自动内存管理&#34;&gt;Java的自动内存管理&lt;/h2&gt;
&lt;p&gt;Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收&lt;/p&gt;
&lt;h3 id=&#34;jvm内存分配&#34;&gt;JVM内存分配&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象a优先在eden区分配&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.若eden区原本有对象b，且有足够的空间，则分配在eden区                                                     2.若eden区没有足够的空间进行分配，虚拟机将发起Minor GC，将对象b存入Survivor空间        3.如果如果对象b无法存入Survivor空间中，则通过分配担保机制存入老年代                            &lt;br&gt;
4.如果老年代没有足够的空间存入对象b，则执行Full GC，总之让eden区有足够的内存存入对象a&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大对象直接进入老年代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要大量连续内存空间的对象，比如字符串、数组&lt;/li&gt;
&lt;li&gt;好处：了避免为⼤对象分配内存时由于分配担保机制带来的复制⽽降低效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;长期存活的对象将进入老年代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给每个对象一个年龄计数器，对象每在Survivor区中存活过一次Minor GC，年龄+1；达到一定年龄（默认15）后进入老年代&lt;/li&gt;
&lt;li&gt;如果Survivor空间中同一年龄的所有对象的总和大于Survivor空间的一半，则年龄大于等于该年龄的对象就可以直接进入老年代&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jvm内存回收&#34;&gt;JVM内存回收&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;强引⽤(StrongReference)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必不可少，当内存空间不⾜，Java虚拟机
宁愿抛出OutOfMemoryError错误，也不回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软引⽤(SoftReference)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个对象只有软引用，当内存空间不⾜了，就会回收这些对象的内存&lt;/li&gt;
&lt;li&gt;可以和⼀个引⽤队列（ReferenceQueue）联合使⽤&lt;/li&gt;
&lt;li&gt;一般用软引用比较多，软引⽤可以加速JVM对垃圾内存的回收速度，可以维护系统的运⾏安全，防⽌内存溢出（OutOfMemory）等问题的产⽣。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;弱引⽤(WeakReference)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收器一旦发现弱引用，不管内存空间是否充足，都回收&lt;/li&gt;
&lt;li&gt;可以和⼀个引⽤队列（ReferenceQueue）联合使⽤&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚引⽤（PhantomReference）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要⽤来跟踪对象被垃圾回收的活动&lt;/li&gt;
&lt;li&gt;如果一个对象有虚引用，那么回收它之前必须将虚引用加入到引用队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;废弃常量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时常量池来回收&lt;/li&gt;
&lt;li&gt;当前没有任何对象来引用此常量，则为废弃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无用的类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例&lt;/li&gt;
&lt;li&gt;加载该类的 ClassLoader 已经被回收&lt;/li&gt;
&lt;li&gt;该类对应的 java.lang.Class 对象没有在任何地⽅被引⽤，⽆法在任何地⽅通过反射访问该类
的⽅法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象是否死亡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引⽤计数法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺点是不能解决对象之间相互循环引用的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可达性分析算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到一系列被称为“GC roots”的对象作为起点，从这些节点向下遍历，走过的路径称为引用链，当一个对象到“GC roots”没有任何一条引用链相连，则说明这个对象不可用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该算法的全过程都需要基于一个能保障一致性的快照中才能够分析，这意味着必须全程冻结用户线程的运行&lt;/li&gt;
&lt;li&gt;1.根节点枚举&lt;/li&gt;
&lt;li&gt;2.向下遍历对象图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GC roots&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机栈中引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中引用的对象&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象&lt;/li&gt;
&lt;li&gt;所有被同步锁持有的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;经过可达性分析为不可达的对象并不会马上回收，需要经过两次标记才可以宣告死亡&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象晋升老年代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.动态对象年龄判断机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.新生代垃圾回收之后，存活对象太多，导致大量对象直接进入老年代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.大对象直接进入老年代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.对象躲过了15次垃圾回收（默认），进入老年代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.空间担保机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;当要MinorGC之前，首先会计算老年代剩余空间是否大于新生代所有对象大小之和(防止极端情况下eden区所有对象都幸存)。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;2.如果剩余空间不够放全部的新生代对象，但是配置了-XX:-HandlePromotionFailure参数（1.6以后废弃），那么就会计算每次MinorGC后存活对象的平均大小，如果老年代剩余内存大小大于这个平均大小，则大胆认为这次MinorGC回收后，老年代还是可以放得下&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;如果该次MinorGC之后老年代的确是放不下就进行Fulll GC，如果Full GC完了还是放不下则oom&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;部分收集 (Partial GC)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新⽣代收集（Minor GC / Young GC）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当eden区内存分配满了时，触发Young GC，然后会有部分对象进入老年代，老年代内存占用会提高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;⽼年代收集（Major GC / Old GC）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;混合收集（Mixed GC）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整堆收集 (Full GC)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当准备触发新生代收集时，如果发现统计数据说之前Young GC的平均晋升大小比目前老年代剩余的空间大，则不会触发Young GC而是转而触发Full GC。&lt;/li&gt;
&lt;li&gt;老年代空间不足&lt;/li&gt;
&lt;li&gt;永久代空间不足：如果有Perm Gen，要在Perm Gen分配空间但已经没有足够的空间时，触发一次Full GC&lt;/li&gt;
&lt;li&gt;使用System.gc()，默认也是触发Full GC&lt;/li&gt;
&lt;li&gt;由eden区向Survivor区复制时，对象大于Survivor内存，同时大于老年代可用空间，则触发Full GC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算法（内存回收的方法论）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;标记-清除算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分“标记”和“清除”阶段，先标记所有存活的对象，然后统一回收没有标记的对象&lt;/li&gt;
&lt;li&gt;1.效率问题     2.空间问题（会产生大量不连续的碎片）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记-复制算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次对内存空间的一半进行回收&lt;/li&gt;
&lt;li&gt;将内存分为两块，标记存活对象，将存活对象复制到另一块内存，然后把这块内存进行回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记-整理算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标记存活对象，把存活对象向一端移动，然后直接清理端边界以外的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分代收集算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据对象存活周期不同将内存分为几块&lt;/li&gt;
&lt;li&gt;新生代使用标记-复制算法，老年代使用标记-清除算法或者标记-整理算法&lt;/li&gt;
&lt;li&gt;分代主要是为了提升GC效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垃圾回收器（内存回收的具体实现）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Serial收集器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生代采用复制算法，老年代采用标记-整理算法&lt;/li&gt;
&lt;li&gt;单线程&lt;/li&gt;
&lt;li&gt;简单高效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ParNew收集器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial收集器的多线程版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Serial Old 收集器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial收集器的老年代版本&lt;/li&gt;
&lt;li&gt;单线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Parallel Scavenge收集器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新生代采用复制算法，老年代采用标记-整理算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关注点是吞吐量（⾼效率的利⽤ CPU）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;吞吐量就是 CPU 中⽤于运⾏⽤户代码
的时间与 CPU 总消耗时间的⽐值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK1.8 默认使⽤的是 Parallel Scavenge + Parallel Old&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Parallel Old 收集器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parallel Scavenge收集器的老年代版本&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CMS收集器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关注点更多的是⽤户线程的停顿时间（提⾼⽤户体验）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记-清除算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;初始标记&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发标记（基于增量更新来做的）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收器和用户线程同时运行，并发工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三色标记法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在遍历对象图的过程中，把访问都的对象按照&amp;quot;是否访问过&amp;quot;这个条件标记成以下三种颜色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;白色&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示对象尚未被垃圾回收器访问过&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;灰色&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;黑色&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示对象已经被垃圾回收器访问过，且这个对象的所有引用都已经扫描过&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少STW，主要是减少从GC roots节点往下遍历对象图并进行标记这一过程的停顿时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带来了问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浮动垃圾&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;产生原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收器在工作时，用户线程在同时修改引用关系，把原本应该回收的对象修改为存活的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下次清理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象消失&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;产生原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收器在工作时，用户线程在同时修改引用关系，把原本应该存活的对象修改为回收的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新标记&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发清除&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发、低停顿&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.对CPU资源敏感&lt;/li&gt;
&lt;li&gt;2.无法处理浮动垃圾&lt;/li&gt;
&lt;li&gt;使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G1收集器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面向服务器，主要针对配备多颗处理器及大容量内存的机器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记&lt;/li&gt;
&lt;li&gt;并发标记&lt;/li&gt;
&lt;li&gt;最终标记&lt;/li&gt;
&lt;li&gt;筛选回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.并发与并行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.分代收集&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.空间整合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整体看是标记-整理算法实现&lt;/li&gt;
&lt;li&gt;局部看是标记-复制算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.可预测的停顿&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZGC 收集器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标记-复制算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;位置&lt;/p&gt;
&lt;p&gt;JVM的GC并不是任何时刻都发生的，只有STW，才会执行GC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安全点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序执行时并非在所有地方都能停顿下来开始GC ， 只有在特定的位置才能停顿下来开始GC ， 这些位置称为“ 安全点（Safepoint）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GC时线程的中断策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢先式中断&lt;/li&gt;
&lt;li&gt;主动式中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环的末尾&lt;/li&gt;
&lt;li&gt;方法临返回前&lt;/li&gt;
&lt;li&gt;调用方法之后&lt;/li&gt;
&lt;li&gt;抛异常的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全区&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全区域是指在一段代码片段中， 对象的引用关系不会发生变化， 在这个区域中的任何位置开始GC 都是安全的。我们也可以把Safe Region 看做是被扩展了的Safepoint&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 、当线程运行到 Safe Region 的代码时， 首先标识己经进入了safe Region ，如果这段时间内发生GC ,JVM会忽略标识为 Safe Region 状态的线程(认为它是安全的)&lt;/li&gt;
&lt;li&gt;2.当线程即将离开时， 会检查JVM是否己经完成GC ， 如果完成 ， 则继续运行， 否则线程必须等待直到收到可以安全离开Safe Region 的信号为止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>JVM（三）Java内存区域</title>
        <link>https://slothhuman.github.io/p/jvm%E4%B8%89java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
        <pubDate>Fri, 27 Jan 2023 00:00:00 +0000</pubDate>
        
        <guid>https://slothhuman.github.io/p/jvm%E4%B8%89java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
        <description>&lt;img src="https://slothhuman.github.io/img/13.jpg" alt="Featured image of post JVM（三）Java内存区域" /&gt;&lt;h2 id=&#34;java内存区域&#34;&gt;Java内存区域&lt;/h2&gt;
&lt;h3 id=&#34;线程私有&#34;&gt;线程私有&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序计数器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执
⾏、选择、循环、异常处理&lt;/li&gt;
&lt;li&gt;在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时
候能够知道该线程上次运⾏到哪⼉了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序计数器是唯⼀⼀个不会出现OutOfMemoryError 的内存区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随着线程的创建⽽创建，随着线程的死亡⽽死亡&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟机栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;栈帧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;局部变量表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要存放编译期可知的各种数据类型与对象引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作数表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法出口信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;错误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;StackOverFlowError 和 OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随着线程的创建⽽创建，随着线程的死亡⽽死亡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;return语句和抛出异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节
码）服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地方法栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程共享&#34;&gt;线程共享&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;堆&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存放对象实例，⼏乎所有的对象实例以及数组都在这⾥分配内存。&lt;/li&gt;
&lt;li&gt;从jdk 1.7开始已经默认开启逃逸分析，如果某些⽅法中的对象引⽤没有被返回或者未被外⾯使⽤（也就是未逃逸出去），那么对象可以直接在栈上分配内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OutOfMemoryError&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本结构（JDK1.7）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新生代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eden区&lt;/li&gt;
&lt;li&gt;Survivor区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老年代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久代&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法区&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JDK 7 版本及JDK 7 版本之前，永生代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM 本身设置固定⼤⼩上限，⽆法进⾏调整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK 8 版本之后，元空间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接内存，受本机可⽤内存的限制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行时常量池&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK1.7之前存放在方法区&lt;/li&gt;
&lt;li&gt;JDK1.7存放在方法区，但字符串常量池被拿到堆中&lt;/li&gt;
&lt;li&gt;JDK1.8存放在方法区，但字符串常量池被拿到堆中，方法区实现变成元空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要⽤于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接内存 (⾮运⾏时数据区的⼀部分)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元空间&lt;/li&gt;
&lt;li&gt;OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>JVM（二）类</title>
        <link>https://slothhuman.github.io/p/jvm%E4%BA%8C%E7%B1%BB/</link>
        <pubDate>Thu, 26 Jan 2023 00:00:00 +0000</pubDate>
        
        <guid>https://slothhuman.github.io/p/jvm%E4%BA%8C%E7%B1%BB/</guid>
        <description>&lt;img src="https://slothhuman.github.io/img/12.jpg" alt="Featured image of post JVM（二）类" /&gt;&lt;h2 id=&#34;类&#34;&gt;类&lt;/h2&gt;
&lt;h3 id=&#34;类文件结构&#34;&gt;类文件结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;魔数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Class文件的标志&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Class文件版本号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常量池&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问标志&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字段表集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法表集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性表集合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类的生命周期&#34;&gt;类的生命周期&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类加载过程&lt;/p&gt;
&lt;p&gt;Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加载&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.通过全类名获取定义此类的二进制字节流&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如：比较常见的就是从 ZIP 包中读取（日后出现的 JAR、EAR、WAR 格式的基础）、其他文件生成（典型应用就是 JSP）等等&lt;/li&gt;
&lt;li&gt;非数组类我们可以去自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）&lt;/li&gt;
&lt;li&gt;数组类型不通过类加载器创建，它由 Java 虚拟机直接创建&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;验证&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件格式验证&lt;/li&gt;
&lt;li&gt;元数据验证&lt;/li&gt;
&lt;li&gt;字节码验证&lt;/li&gt;
&lt;li&gt;符号引用验证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备阶段是正式为类变量（即静态变量）分配内存并设置类变量初始值（数据类型默认的零值）的阶段，这些内存都将在方法区分配&lt;/li&gt;
&lt;li&gt;而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;必须对类进行初始化的情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时&lt;/li&gt;
&lt;li&gt;使用 java.lang.reflect 包的方法对类进行反射调用时如 Class.forname(&amp;quot;&amp;hellip;&amp;quot;), newInstance() 等等。如果类没初始化，需要触发其初始化&lt;/li&gt;
&lt;li&gt;初始化一个类，如果其父类还未初始化，则先触发该父类的初始化&lt;/li&gt;
&lt;li&gt;当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类&lt;/li&gt;
&lt;li&gt;MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类&lt;/li&gt;
&lt;li&gt;当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卸载&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;卸载类即该类的 Class 对象被 GC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;满足3个要求即可卸载类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。&lt;/li&gt;
&lt;li&gt;该类没有在其他任何地方被引用&lt;/li&gt;
&lt;li&gt;该类的类加载器的实例已被 GC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>JVM（一）Java对象</title>
        <link>https://slothhuman.github.io/p/jvm%E4%B8%80java%E5%AF%B9%E8%B1%A1/</link>
        <pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate>
        
        <guid>https://slothhuman.github.io/p/jvm%E4%B8%80java%E5%AF%B9%E8%B1%A1/</guid>
        <description>&lt;img src="https://slothhuman.github.io/img/11.jpg" alt="Featured image of post JVM（一）Java对象" /&gt;&lt;h2 id=&#34;java对象&#34;&gt;Java对象&lt;/h2&gt;
&lt;h3 id=&#34;java对象创建&#34;&gt;Java对象创建&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.类加载检查&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机遇到new指令，检查这个类之前是否加载过，若没有就执行类加载检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.分配内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分配方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指针碰撞&lt;/li&gt;
&lt;li&gt;空闲列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择哪种方式由Java堆是否规整决定，⽽ Java 堆内存是否规整，取决于GC 收集器的算法是&amp;quot;标记-清除&amp;quot;，还是&amp;quot;标记-整理&amp;quot;（也称作&amp;quot;标记-压缩&amp;quot;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.初始化零值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.设置对象头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.执行init方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对象访问定位&#34;&gt;对象访问定位&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;句柄&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java堆中划分一块内存作为句柄池，句柄池中包含“到对象实例数据的指针”和“到对象类型数据的指针”，reference存储对象的句柄地址。&lt;/li&gt;
&lt;li&gt;假如对象移动时，reference存储对象的句柄地址不需要改变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接指针&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象中包含“对象实例数据”和“到对象类型数据的指针”，⽽reference 中存储的直接就是对象的地址。&lt;/li&gt;
&lt;li&gt;速度快，节省了⼀次指针定位的时间开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
