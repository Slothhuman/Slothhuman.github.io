<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>OS on Slothhuman&#39;s Blog</title>
        <link>https://slothhuman.github.io/tags/os/</link>
        <description>Recent content in OS on Slothhuman&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Thu, 19 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://slothhuman.github.io/tags/os/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>操作系统（四）内存管理</title>
        <link>https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <pubDate>Thu, 19 Jan 2023 00:00:00 +0000</pubDate>
        
        <guid>https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        <description>&lt;img src="https://slothhuman.github.io/img/8.jpg" alt="Featured image of post 操作系统（四）内存管理" /&gt;&lt;h2 id=&#34;内存管理&#34;&gt;内存管理&lt;/h2&gt;
&lt;h3 id=&#34;内存管理主要是做什么&#34;&gt;内存管理主要是做什么&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;内存的分配与回收&lt;/li&gt;
&lt;li&gt;地址转换即将逻辑地址转换成相应的物理地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内存管理方式&#34;&gt;内存管理方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;连续分配管理方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块式管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非连续分配管理方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页式管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页式管理通过页表对应逻辑地址和物理地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页是物理单位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页与页之间是离散的，页中的内存是连续的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了提高虚拟地址到物理地址的转换速度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级页表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间换空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段式管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;段式管理通过段表对应逻辑地址和物理地址。&lt;/li&gt;
&lt;li&gt;段是有实际意义的，每个段定义了一组逻辑信息&lt;/li&gt;
&lt;li&gt;段与段之间是离散的，段中的内存是连续的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段页式管理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;逻辑虚拟地址与物理地址&#34;&gt;逻辑（虚拟）地址与物理地址&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以用一系列相邻的虚拟内存来代表物理内存中不相邻的大内存缓冲区，然后访问&lt;/li&gt;
&lt;li&gt;程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。&lt;/li&gt;
&lt;li&gt;不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物理地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不足&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果直接把物理地址暴露出来的话会带来严重问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;虚拟内存时间换空间&#34;&gt;虚拟内存（时间换空间）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;虚拟内存是计算机系统管理内存的一种技术&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟内存的重要意义是它定义了一个连续的虚拟内存空间，并把内存扩展到了硬盘空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求分页存储管理&lt;/li&gt;
&lt;li&gt;请求分段存储管理&lt;/li&gt;
&lt;li&gt;请求段页式存储管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面置换算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OPT 页面置换算法（最佳页面置换算法）&lt;/li&gt;
&lt;li&gt;FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）&lt;/li&gt;
&lt;li&gt;LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）&lt;/li&gt;
&lt;li&gt;LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统（三）线程</title>
        <link>https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%E7%BA%BF%E7%A8%8B/</link>
        <pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate>
        
        <guid>https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%E7%BA%BF%E7%A8%8B/</guid>
        <description>&lt;img src="https://slothhuman.github.io/img/5.jpg" alt="Featured image of post 操作系统（三）线程" /&gt;&lt;h2 id=&#34;线程&#34;&gt;线程&lt;/h2&gt;
&lt;h3 id=&#34;状态&#34;&gt;状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NEW（新建）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程刚刚创建的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;READY（就绪）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用start()方法后&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RUNNABLE（运⾏中）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获得时间片后&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WAITING（等待）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行wait()后进入等待，执行notify()后回到可运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TIME_WAITING(超时等待)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行wait(long)或者sleep(long)后进入超时等待，时间到或者notify()后回到可运行状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BLOCKED（阻塞）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用同步方法时，在没有获得锁的情况下就会阻塞,获得锁后又回到可运行状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TERMINATED（终⽌）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行run()后&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程间同步的方式&#34;&gt;线程间同步的方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;互斥量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥对象机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多线程&#34;&gt;多线程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可能带来的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存泄露&lt;/li&gt;
&lt;li&gt;上下文切换&lt;/li&gt;
&lt;li&gt;死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多线程使用原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算机底层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;资源的花销&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多核CPU时，多个线程可以同时运行，减少了线程上下文切换的开销&lt;/li&gt;
&lt;li&gt;线程量级较小，线程间的切换和调度成本远小于进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单核&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;此时多线程是为了提高CPU和IO设备的综合利用率&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即CPU工作时不能让IO设备闲着&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多核&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;此时是为了提高CPU的利用率&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有多个CPU，这个CPU工作时，不能让其他CPU闲着&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当代互联网发展趋势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统要求的并发量非常高，利用多线程可以提供系统的并发能力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统（二）进程</title>
        <link>https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%E8%BF%9B%E7%A8%8B/</link>
        <pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate>
        
        <guid>https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%E8%BF%9B%E7%A8%8B/</guid>
        <description>&lt;img src="https://slothhuman.github.io/img/6.jpg" alt="Featured image of post 操作系统（二）进程" /&gt;&lt;h2 id=&#34;进程&#34;&gt;进程&lt;/h2&gt;
&lt;h3 id=&#34;状态&#34;&gt;状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就绪状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一旦得到处理器分配的时间片就可以运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程正在处理器上运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结束状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程间通信方式&#34;&gt;进程间通信方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;管道/匿名管道&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父子进程或兄弟进程&lt;/li&gt;
&lt;li&gt;只存在于内存中的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有名管道&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先进先出&lt;/li&gt;
&lt;li&gt;以磁盘文件的方式存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息队列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通信数据先进先出&lt;/li&gt;
&lt;li&gt;存放在内核中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套接字&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度算法&#34;&gt;调度算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先到先服务调度算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给最快进入就绪队列的进程分配资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;短作业优先调度算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选出一个估计运行时间最短的进程，给它分配资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间片轮转调度算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给每个进程分配时间片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级反馈队列调度算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优先级调度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;死锁&#34;&gt;死锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产生死锁的四个必要条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;互斥&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源为非共享，即一次只能由一个线程使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;占用并等待&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非抢占&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环等待&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决死锁的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;预防&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用某种策略，限制并发进程对资源的请求，使得死锁的必要条件不满足，破坏四大必要条件中的一个就行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;破坏“占用并等待”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态分配策略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;破坏“循环等待”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;层次分配策略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在系统分配资源时，根据资源的使用情况做出预测，从而避免死锁的发生（允许四大必要条件同时存在）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;银行家算法判断系统是否处于安全状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检测&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统定时地运行一个“死锁检测”程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立即结束所有进程的执行，重新启动操作系统&lt;/li&gt;
&lt;li&gt;撤销涉及死锁的所有进程，解除死锁后继续运行&lt;/li&gt;
&lt;li&gt;逐个撤销涉及死锁的进程，回收其资源直至死锁解除&lt;/li&gt;
&lt;li&gt;抢占资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统（一）基础</title>
        <link>https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%80%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate>
        
        <guid>https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%80%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;img src="https://slothhuman.github.io/img/4.jpg" alt="Featured image of post 操作系统（一）基础" /&gt;&lt;h2 id=&#34;基础&#34;&gt;基础&lt;/h2&gt;
&lt;h3 id=&#34;系统调用&#34;&gt;系统调用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设备管理&lt;/li&gt;
&lt;li&gt;文件管理&lt;/li&gt;
&lt;li&gt;进程控制&lt;/li&gt;
&lt;li&gt;进程通信&lt;/li&gt;
&lt;li&gt;内存管理&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
