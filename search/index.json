[{"content":"什么是SDK调用方式 SDK调用方式是现代软件开发中常用的一种方式，它通过提供简单易用的接口，让开发者可以轻松地调用第三方API，避免了繁琐的HTTP请求和参数处理。使用SDK调用方式可以大大提高开发效率和代码可读性，同时也能够降低出错的风险。\n什么是SDK SDK全称为Software Development Kit，中文名为软件开发工具包，是一种为特定软件包、软件框架、硬件平台、操作系统等开发者提供的一系列工具的集合，它包含了开发所需的一些资源、API、文档、示例代码等。SDK的目的是简化开发者的工作，提供一些常用的开发工具和接口，使开发者能够快速地开发出满足业务需求的软件或应用。一些著名的SDK包括Android SDK、iOS SDK、AWS SDK等。\nSDK调用方式的特点 SDK调用方式是指使用第三方提供的SDK来调用其API，这种方式相对于直接调用API具有以下几个特点：\n封装性：SDK通常会对API进行封装，使得调用更加简单易用； 统一性：SDK提供了统一的接口和规范，可以方便地进行开发和维护； 兼容性：SDK通常会提供多种编程语言的版本，以便不同编程语言的开发者使用； 可靠性：SDK通常会对API进行错误处理和异常处理，提高调用的可靠性。 SDK调用方式的优势（使用别人的SDK） 使用SDK调用方式具有以下优势：\n提高开发效率：使用SDK可以避免开发者自己编写大量的代码来调用API，从而节省了时间和精力； 提高调用的可靠性：SDK通常会对API进行错误处理和异常处理，提高了调用的可靠性； 方便快捷：SDK通常提供了示例代码和文档，开发者可以很方便地进行开发和调试； 降低开发成本：使用SDK可以降低开发成本，避免了重复造轮子。 为自定义的接口封装一个SDK的优势（使用自己的SDK） 简化接口调用流程：SDK将复杂的接口调用流程封装起来，用户只需要调用SDK提供的接口方法即可完成接口调用，避免了用户需要了解底层接口实现的复杂性。 提高开发效率：SDK可以提供更友好的API，降低使用接口的门槛，简化开发流程，从而提高开发效率。 提高代码复用率：SDK可以将接口调用相关的代码封装在一起，使得接口调用逻辑可以被多个项目复用，减少重复开发的工作量。 方便版本升级：当接口升级时，只需要修改SDK的实现，而不需要修改使用该接口的所有项目，降低了接口升级的成本。 提高可维护性：封装SDK的过程中，可以将接口调用的异常处理、日志记录等细节封装在一起，使得代码更易于维护。 SDK调用方式的实现原理： 使用SDK调用第三方API的方式通常是通过对应的SDK库来实现的。 SDK库通常封装了API调用的具体实现，包括请求参数的构建、请求的发送和响应的处理等。 调用SDK库需要先进行初始化，通常需要传入API的认证信息、请求地址、端口号等配置信息。 通过调用SDK库提供的API接口，将构建好的请求参数传入，即可完成对第三方API的调用。 SDK调用适用于以下场景： 需要频繁调用第三方API的应用程序，例如支付、短信发送、邮件发送等。 需要简化API调用过程的应用程序，例如通过SDK可以提供更高层次的封装，减少编码量和出错率。 需要快速开发并且集成第三方服务的应用程序，例如SDK可以提供开发文档和示例代码，快速上手并集成第三方服务。 ","date":"2022-12-22T00:00:00Z","image":"https://slothhuman.github.io/img/2.jpg","permalink":"https://slothhuman.github.io/p/api%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F-sdk%E8%B0%83%E7%94%A8/","title":"API调用方式-SDK调用"},{"content":"什么是RPC调用 RPC（Remote Procedure Call）是一种远程过程调用协议，它允许程序在不同的计算机节点之间进行通信和数据交换。简单来说，RPC就是一种能够像调用本地函数一样调用远程函数的协议。\n在分布式系统中，不同的服务通常需要通过网络进行通信，而RPC调用就是为了简化这个过程。通过RPC调用，我们可以像本地调用一样直接调用远程服务中的函数，而无需关心底层网络通信细节。这样可以使得分布式系统的开发更加高效和便捷。\nRPC调用的过程包括请求发送、远程服务调用、响应返回等步骤，其工作流程与本地函数调用类似。RPC调用协议中定义了一些规范，包括消息的格式、传输协议、序列化方式等。这些规范使得不同的RPC框架可以进行通信和交互，从而实现跨语言、跨平台的服务调用。\n适用场景 RPC（Remote Procedure Call）调用方式广泛应用于分布式系统和微服务架构中，特别是在以下场景中：\n高并发、大流量的服务场景。RPC 能够有效地提高系统性能和响应速度，通过将服务请求分散到多个节点上进行并行处理，从而提高了系统的吞吐量和处理能力。 复杂的系统架构。RPC 能够帮助系统将逻辑分离，提高代码复用性，降低系统耦合度。通过使用 RPC，不同的系统组件可以分别部署在不同的服务器上，实现分布式部署和维护。 多语言环境下的服务调用。RPC 能够支持多种编程语言，使得不同的系统组件可以使用不同的编程语言实现，并且无需对外部系统的编程语言进行了解，降低了系统的开发难度和成本。 异构系统集成。RPC 能够实现异构系统之间的数据交换和服务调用，可以将不同的系统组件集成在一起，构建一个高效可靠的系统。 服务治理。RPC 框架通常提供丰富的服务治理功能，如负载均衡、服务注册、熔断机制等，能够帮助系统实现高可用性和容错性，提升系统的稳定性和可靠性。 RPC调用的优势 RPC调用相对于传统的HTTP请求调用，有以下几个优势：\n更高的性能：RPC框架通常采用二进制协议，传输数据量更小，效率更高。而HTTP请求调用采用文本协议，传输数据量较大，效率较低。 更好的扩展性：RPC框架支持多种协议和序列化方式，可以根据实际需要进行灵活选择，更好地适应不同的场景需求。同时，RPC框架通常支持服务发现、负载均衡、容错等功能，可以更方便地进行服务治理。 更强的安全性：RPC框架通常支持加密传输、身份认证等安全机制，可以更好地保障服务调用的安全性。 更好的开发体验：RPC框架通常提供了更方便的服务调用方式，如接口代理、动态代理等，可以更快捷地进行开发。 原理 RPC的基本原理是客户端像调用本地方法一样，通过网络请求远程服务器上的方法，服务器执行方法并返回结果，客户端拿到结果并进行处理。在RPC调用中，远程调用的实现一般分为以下步骤：\n客户端调用本地存根（stub）方法，并将调用的方法和参数封装成消息对象； 客户端向远程服务发起请求，将消息对象发送到远程服务； 服务端接收到请求后，反序列化消息对象，解析出调用的方法和参数； 服务端执行对应的方法，并将返回结果封装成消息对象； 服务端将消息对象序列化后发送给客户端； 客户端接收到消息对象后反序列化，获取返回结果。 RPC的实现原理主要涉及序列化、网络传输、反序列化等技术。序列化是将对象转化成二进制流的过程，网络传输是将序列化后的二进制流进行传输，反序列化则是将二进制流转化成对象的过程。常用的序列化协议有JSON、XML、Hessian、Thrift、Protocol Buffers等，网络传输方式主要有HTTP、TCP、UDP等协议。\n常用的RPC框架 有很多，其中一些比较流行的包括：\ngRPC：由Google开源的高性能RPC框架，基于HTTP/2协议，使用Protocol Buffers作为IDL和序列化工具，支持多种语言。 Dubbo：阿里巴巴开源的分布式服务框架，支持多种协议和序列化方式，提供服务治理和负载均衡等功能。 Thrift：由Facebook开源的跨语言RPC框架，支持多种编程语言，使用自定义IDL和二进制协议进行通信。 gRPC-Web：gRPC的Web版本，支持在Web浏览器中进行gRPC调用。 Spring Cloud：基于Spring框架的微服务框架，包括了众多的子框架，如Eureka、Ribbon、Feign等。 Apache CXF：开源的服务框架，支持多种协议和数据格式，包括SOAP、REST、JSON、XML等。 使用RPC调用自定义接口的步骤 下面我将介绍如何使用 Dubbo 框架来实现 RPC 调用自定义接口的步骤\n步骤如下：\n1.首先需要定义服务接口，即提供哪些方法可以供其他服务调用。在 Dubbo 框架中，可以使用 Java 接口的方式定义服务接口。例如，我们定义一个示例服务接口 HelloService：\n1 2 3 public interface HelloService { String sayHello(String name); } 2.实现服务接口。在 Dubbo 框架中，服务实现类需要实现服务接口中定义的方法。例如，我们实现一个示例服务实现类 HelloServiceImpl：\n1 2 3 4 5 public class HelloServiceImpl implements HelloService { public String sayHello(String name) { return \u0026#34;Hello \u0026#34; + name; } } 3.配置 Dubbo 服务提供者。在 Dubbo 中，服务提供者需要将服务注册到注册中心，并监听指定的端口，等待其他服务的调用。可以通过 XML 配置文件或注解的方式来配置服务提供者。例如，我们使用 XML 配置文件来配置服务提供者：\n1 2 3 4 5 6 7 8 9 \u0026lt;dubbo:application name=\u0026#34;hello-service-provider\u0026#34; /\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://localhost:2181\u0026#34; /\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; port=\u0026#34;20880\u0026#34; /\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;com.example.service.HelloService\u0026#34; ref=\u0026#34;helloService\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;helloService\u0026#34; class=\u0026#34;com.example.service.impl.HelloServiceImpl\u0026#34; /\u0026gt; 其中，dubbo:application 指定服务名称，dubbo:registry 指定注册中心地址，dubbo:protocol 指定协议和端口，dubbo:service 指定服务接口和实现类，ref 指定实现类的实例化对象。\n4.配置 Dubbo 服务消费者。在 Dubbo 中，服务消费者需要从注册中心获取服务提供者的地址，并通过远程调用来调用服务。同样可以通过 XML 配置文件或注解的方式来配置服务消费者。例如，我们使用 XML 配置文件来配置服务消费者：\n1 2 3 4 5 6 7 8 9 \u0026lt;dubbo:application name=\u0026#34;hello-service-consumer\u0026#34; /\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://localhost:2181\u0026#34; /\u0026gt; \u0026lt;dubbo:reference id=\u0026#34;helloService\u0026#34; interface=\u0026#34;com.example.service.HelloService\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;helloController\u0026#34; class=\u0026#34;com.example.controller.HelloController\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;helloService\u0026#34; ref=\u0026#34;helloService\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 其中，dubbo:application 指定服务名称，dubbo:registry 指定注册中心地址，dubbo:reference 指定服务接口，id 指定服务引用的名称，bean 定义消费者 Controller 类，property 注入服务引用。\n5.最后，我们可以在消费者 Controller 类中通过服务引用来调用服务。例如，我们定义一个示例 Controller 类 HelloController：\n1 2 3 4 5 6 7 8 9 @RestController public class HelloController { @Reference private HelloService helloService; @GetMapping(\u0026#34;/hello\u0026#34;) public String sayHello(@RequestParam String name) { return helloService.sayHello(name); } 在上面的示例中，我们使用 @Reference 注解来自动注入 HelloService 接口的实现对象，从而可以直接调用 sayHello 方法来获取服务提供者返回的结果。同时，我们也定义了一个示例的 GET 请求接口 /hello，用于测试服务是否正常运行。\nRPC调用的注意事项及异常处理 当使用 RPC 调用时，需要注意以下几个事项：\n服务接口的定义需要保持一致：在使用 RPC 调用时，服务接口的定义需要在服务提供者和服务消费者之间保持一致，否则会出现调用失败或异常的情况。 服务提供者和消费者的版本需要匹配：在使用 RPC 调用时，服务提供者和服务消费者的版本需要匹配，否则也会出现调用失败或异常的情况。 网络传输的稳定性：RPC 调用依赖于网络传输，在网络不稳定的情况下，会导致调用失败或超时。因此，在实际使用时，需要保证网络传输的稳定性，可以使用负载均衡、重试等机制来提高调用的成功率。 服务端出现异常需要正确处理：在服务提供者出现异常的情况下，需要正确处理异常，避免对整个系统产生影响。可以使用异常处理机制或者日志记录等方式来处理异常。 安全性：由于 RPC 调用是基于网络传输的，因此需要保证传输数据的安全性，可以使用 SSL、加密等方式来保证数据的安全传输。 在 RPC 调用过程中，可能会出现以下几种异常情况：\n调用超时异常：当调用时间超过指定时间时，会抛出调用超时异常，可以通过设置超时时间或调整服务负载来解决。 服务提供者不可用异常：当服务提供者无法正常提供服务时，会抛出服务提供者不可用异常，可以通过检查服务提供者的状态或进行服务降级来解决。 连接异常：当网络连接中断或服务提供者不可用时，会抛出连接异常，可以通过重试机制或检查网络连接状态来解决。 序列化异常：当序列化或反序列化过程中出现异常时，会抛出序列化异常，可以检查数据格式或使用其他序列化方式来解决。 其他异常：在 RPC 调用过程中，还可能出现其他异常，例如服务提供者异常、网络故障等，需要根据具体情况进行处理。 ","date":"2022-12-18T00:00:00Z","image":"https://slothhuman.github.io/img/green.jpg","permalink":"https://slothhuman.github.io/p/rpc%E8%B0%83%E7%94%A8/","title":"RPC调用"},{"content":"HTTP请求工具 HTTP请求工具可以帮助我们方便地发送HTTP请求，并查看响应结果。常见的HTTP请求工具有Postman、Insomnia等，也可以使用编程语言自带的HTTP库或第三方HTTP库进行请求发送。我们这里主要介绍编程语言自带的HTTP库或第三方HTTP库\nJava原生的HttpURLConnection类 HttpURLConnection是Java原生的HTTP客户端库之一，用于实现HTTP连接和请求。它提供了许多可用于控制请求和响应的方法和属性。\nHttpURLConnection支持多种HTTP请求方法，包括GET、POST、PUT、DELETE等，并支持对请求头和请求参数进行自定义配置。此外，它还提供了一些用于获取响应状态码、响应头和响应体等响应信息的方法。\n使用HttpURLConnection发送HTTP请求需要以下步骤：\n创建一个URL对象，该对象表示HTTP请求的URL。 调用URL对象的openConnection()方法打开与URL之间的连接，并将返回一个HttpURLConnection对象。 通过HttpURLConnection对象设置HTTP请求方法、请求头、请求参数等。 调用HttpURLConnection对象的getInputStream()方法获取输入流，用于读取服务器响应。 读取服务器响应，可以使用BufferedReader、InputStreamReader等工具类。 以下是使用HttpURLConnection发送GET请求的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.net.HttpURLConnection; import java.net.URL; import java.io.BufferedReader; import java.io.InputStreamReader; public class HttpUtils { public static String sendGetRequest(String url) throws Exception { HttpURLConnection conn = null; BufferedReader in = null; StringBuilder result = new StringBuilder(); try { URL realUrl = new URL(url); // 打开和URL之间的连接 conn = (HttpURLConnection) realUrl.openConnection(); // 设置请求头 conn.setRequestProperty(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); conn.setRequestMethod(\u0026#34;GET\u0026#34;); // 获取URLConnection对象对应的输入流 in = new BufferedReader(new InputStreamReader(conn.getInputStream(), \u0026#34;UTF-8\u0026#34;)); String line; while ((line = in.readLine()) != null) { result.append(line); } } catch (Exception e) { throw e; } finally { // 关闭资源 if (in != null) { in.close(); } if (conn != null) { conn.disconnect(); } } return result.toString(); } } 上面的代码通过Java的HttpURLConnection类实现了发送GET请求，并且设置了请求头。可以通过调用该工具类中的sendGetRequest()方法发送GET请求。例如：\n1 2 3 4 5 6 7 8 9 10 11 public class Main { public static void main(String[] args) { try { String url = \u0026#34;https://example.com/api\u0026#34;; String response = HttpUtils.sendGetRequest(url); System.out.println(response); } catch (Exception e) { e.printStackTrace(); } } } 在上面的示例代码中，我们调用了sendGetRequest()方法发送了一个GET请求，并将返回的响应输出到控制台。其中，请求URL为https://example.com/api。\nApache HttpClient库 Apache HttpClient是一个流行的Java HTTP客户端库，它提供了比Java原生HttpURLConnection更简单和强大的API，允许您在Java应用程序中以编程方式发送HTTP/HTTPS请求并处理响应。\n下面是使用Apache HttpClient发送HTTP POST请求的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import java.io.IOException; import org.apache.http.HttpEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; public class HttpClientExample { public static void main(String[] args) throws IOException { // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建HttpPost对象 HttpPost httpPost = new HttpPost(\u0026#34;http://example.com/api\u0026#34;); // 设置请求头信息 httpPost.setHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); // 设置请求体内容 String requestBody = \u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;John\\\u0026#34;, \\\u0026#34;age\\\u0026#34;:30}\u0026#34;; StringEntity requestEntity = new StringEntity(requestBody); httpPost.setEntity(requestEntity); // 执行请求 CloseableHttpResponse response = httpClient.execute(httpPost); // 处理响应 try { // 获取响应实体 HttpEntity responseEntity = response.getEntity(); if (responseEntity != null) { String responseString = EntityUtils.toString(responseEntity); System.out.println(responseString); } } finally { response.close(); } } } 上面的代码示例中，我们首先创建一个HttpClient对象，然后创建一个HttpPost对象，并设置请求的URL和请求头信息。接下来，我们将请求体的内容设置为JSON格式的字符串，并将其设置为请求实体。最后，我们执行POST请求，并处理响应。\n在处理响应时，我们首先获取响应实体，然后将其转换为字符串并输出到控制台。最后，我们在finally块中关闭响应对象，以确保资源得到释放。\nApache HttpClient库具有丰富的API和配置选项，使其成为Java应用程序中发送HTTP请求的首选库之一。\nSpring RestTemplate Spring RestTemplate是Spring框架提供的一个基于HTTP的RESTful客户端库，用于在Java应用程序中发送HTTP请求并处理响应。它提供了比Java原生HttpURLConnection更简单和方便的API，允许您以编程方式发送HTTP/HTTPS请求。\n下面是使用Spring RestTemplate发送HTTP POST请求的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import org.springframework.http.HttpEntity; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpMethod; import org.springframework.http.MediaType; import org.springframework.http.ResponseEntity; import org.springframework.util.LinkedMultiValueMap; import org.springframework.util.MultiValueMap; import org.springframework.web.client.RestTemplate; public class RestTemplateExample { public static void main(String[] args) { // 创建RestTemplate对象 RestTemplate restTemplate = new RestTemplate(); // 设置请求头信息 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); // 设置请求体内容 MultiValueMap\u0026lt;String, String\u0026gt; requestBody = new LinkedMultiValueMap\u0026lt;\u0026gt;(); requestBody.add(\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;); requestBody.add(\u0026#34;age\u0026#34;, \u0026#34;30\u0026#34;); // 封装请求头和请求体 HttpEntity\u0026lt;MultiValueMap\u0026lt;String, String\u0026gt;\u0026gt; requestEntity = new HttpEntity\u0026lt;\u0026gt;(requestBody, headers); // 发送POST请求 ResponseEntity\u0026lt;String\u0026gt; responseEntity = restTemplate.exchange(\u0026#34;http://example.com/api\u0026#34;, HttpMethod.POST, requestEntity, String.class); // 获取响应体内容 String responseBody = responseEntity.getBody(); System.out.println(responseBody); } } 在上面的代码示例中，我们首先创建一个RestTemplate对象，然后设置请求头信息和请求体内容。接下来，我们将请求头和请求体封装为HttpEntity对象，并使用exchange()方法发送POST请求。在处理响应时，我们首先获取响应实体，然后将其转换为字符串并输出到控制台。\nSpring RestTemplate类还提供了其他的API，比如getForObject()、postForObject()、postForEntity()等方法，可以方便地发送HTTP请求和处理响应。\n总体而言，Spring RestTemplate是一个易于使用的HTTP客户端库，适用于各种HTTP请求场景。\n使用HTTP请求调用自定义接口的步骤 1.了解自定义接口的URL、请求方法、请求参数等信息。 在使用HTTP请求调用自定义接口之前，需要先了解自定义接口的一些基本信息，包括接口的URL地址、请求方法（GET、POST等）以及请求参数的格式和内容等。\n2.选择合适的HTTP请求工具。 根据项目的需要和自己的习惯，可以选择适合自己的HTTP请求工具。常见的HTTP请求工具包括Java原生的HttpURLConnection类、Apache HttpClient库、Spring RestTemplate类、OkHttp库、Retrofit库等。\n3.根据自定义接口的请求方法，构建HTTP请求对象。 根据自定义接口的请求方法，构建相应的HTTP请求对象，可以使用HTTP请求工具提供的API或者自己手动构建。例如，使用Java原生的HttpURLConnection类，可以通过如下方式构建HTTP请求对象：\n1 2 3 URL url = new URL(\u0026#34;http://www.example.com/api\u0026#34;); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\u0026#34;GET\u0026#34;); 4.设置HTTP请求参数。 根据自定义接口的请求参数格式，设置HTTP请求参数。对于不同的HTTP请求工具，设置HTTP请求参数的方式可能有所不同。以Java原生的HttpURLConnection类为例，可以使用setRequestProperty方法设置HTTP请求头，使用getOutputStream方法向服务器发送请求体参数，例如：\n1 2 3 4 5 6 connection.setRequestProperty(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); String requestBody = \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;John\\\u0026#34;, \\\u0026#34;age\\\u0026#34;: 30}\u0026#34;; OutputStream os = connection.getOutputStream(); os.write(requestBody.getBytes()); os.flush(); os.close(); 5.发送HTTP请求，并等待接口响应。 调用HTTP请求对象的connect方法发送HTTP请求，并等待接口响应。例如，在使用Java原生的HttpURLConnection类发送HTTP请求后，可以通过getInputStream方法获取接口响应：\n1 2 3 connection.connect(); InputStream is = connection.getInputStream(); // 处理接口响应 6.解析HTTP响应，获取响应状态码、响应头、响应体等信息。 根据需要，解析HTTP响应，获取响应状态码、响应头、响应体等信息。对于不同的HTTP请求工具，解析HTTP响应的方式可能有所不同。例如，在使用Java原生的HttpURLConnection类获取HTTP响应后，可以通过getResponseCode方法获取响应状态码：\n1 int statusCode = connection.getResponseCode(); 7.根据业务需求处理接口返回的数据。 根据自定义接口的返回数据格式和业务需求，处理接口返回的数据。例如，在使用Spring RestTemplate类发送HTTP请求后，可以使用getForObject方法获取响应体，并将其转化为Java对象：\n1 2 3 RestTemplate restTemplate = new RestTemplate(); String url = \u0026#34;http://www.example.com/api\u0026#34;; MyObject myObject = restTemplate.getForObject(url, MyObject.class); 一个简单的HTTP请求调用自定义接口的示例 此示例使用的是Java原生的HttpURLConnection类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import java.net.HttpURLConnection; import java.net.URL; import java.io.BufferedReader; import java.io.InputStreamReader; public class HttpExample { public static void main(String[] args) { try { // 创建连接对象 URL url = new URL(\u0026#34;http://your-api-url.com\u0026#34;); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); // 设置请求方法和请求头 conn.setRequestMethod(\u0026#34;POST\u0026#34;); conn.setRequestProperty(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); conn.setRequestProperty(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;); // 设置请求体（可选） String requestBody = \u0026#34;{\\\u0026#34;param1\\\u0026#34;:\\\u0026#34;value1\\\u0026#34;,\\\u0026#34;param2\\\u0026#34;:\\\u0026#34;value2\\\u0026#34;}\u0026#34;; conn.setDoOutput(true); conn.getOutputStream().write(requestBody.getBytes()); // 发起请求并获取响应 int responseCode = conn.getResponseCode(); BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream())); String inputLine; StringBuffer response = new StringBuffer(); while ((inputLine = in.readLine()) != null) { response.append(inputLine); } in.close(); // 处理响应结果 System.out.println(\u0026#34;Response Code : \u0026#34; + responseCode); System.out.println(\u0026#34;Response Body : \u0026#34; + response.toString()); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2022-12-10T00:00:00Z","image":"https://slothhuman.github.io/img/blue.jpg","permalink":"https://slothhuman.github.io/p/%E4%BD%BF%E7%94%A8http%E8%AF%B7%E6%B1%82%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3/","title":"使用HTTP请求调用自定义接口"},{"content":"简介 当今的应用程序通常需要与其他应用程序或服务进行通信，以实现数据的共享和协作。为了实现这种通信，通常需要使用API（Application Programming Interface）接口，而自定义API接口允许应用程序与其他应用程序或服务进行交互。\n而HTTP请求是应用程序之间最常用的通信方式之一，它允许应用程序通过网络向其他应用程序或服务发送请求，并接收返回的响应，使用HTTP请求可以使应用程序与其他应用程序或服务进行交互，共享数据和资源。\nHTTP请求方法 HTTP请求方法是HTTP协议定义的一组标准方法，用于指示客户端要执行的操作类型。常用的HTTP请求方法包括GET、POST、PUT和DELETE。\nGET 用于从服务器获取资源，通过查询参数传递参数，不会改变服务器状态。通常用于获取数据。\nPOST 用于向服务器提交数据，通过请求体传递参数，可能会改变服务器状态。通常用于提交数据，如表单提交、上传文件等。\nPUT 用于向服务器更新资源，通过请求体传递参数，可能会改变服务器状态。通常用于更新数据，如更新文件、更新文章等。\nDELETE 用于从服务器删除资源，通过查询参数传递参数，可能会改变服务器状态。通常用于删除数据。\n其他方法 除了上述常见的HTTP请求方法，还有一些其他的HTTP请求方法，如OPTIONS、HEAD、PATCH等，但它们使用较少，本文不作过多介绍。\n在使用HTTP请求时，应该根据实际需求选择合适的HTTP请求方法，例如，如果只需要获取数据，应该使用GET方法；如果需要向服务器提交数据，应该使用POST方法；如果需要更新数据，应该使用PUT方法；如果需要删除数据，应该使用DELETE方法。此外还需要根据HTTP规范设置请求头和请求体。\nHTTP请求参数 HTTP请求参数是客户端向服务器传递信息的一种方式，包括查询参数、请求头和请求体。\n查询参数 查询参数是通过URL的查询字符串传递的键值对，使用“?”分隔URL和查询参数，使用“\u0026amp;”连接多个查询参数。\n例如，调用一个获取用户信息的接口，需要传递用户ID和名称两个查询参数：\n1 https://example.com/api/users?id=123\u0026amp;name=John 请求头 请求头是HTTP请求中的一部分，包括各种元数据信息，以键值对的形式表示。常用的请求头包括Content-Type、Authorization、Accept等。例如，以下是使用请求头指定请求体类型的示例：\n1 2 3 4 5 POST /api/users HTTP/1.1 Host: example.com Content-Type: application/json {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:18} 这个示例中，通过POST方法向example.com的/api/users接口提交JSON格式的请求体，使用Content-Type请求头指定请求体类型为application/json。\n请求体 请求体是POST、PUT等方法中发送的数据，用于向服务器提交数据，通常使用JSON或表单数据格式。例如，以下是使用请求体提交表单数据的示例：\n1 2 3 4 5 POST /api/users HTTP/1.1 Host: example.com Content-Type: application/x-www-form-urlencoded name=John\u0026amp;age=18 这个示例中，通过POST方法向example.com的/api/users接口提交表单数据，使用Content-Type请求头指定请求体类型为application/x-www-form-urlencoded。\n在使用HTTP请求时，应该根据实际需求选择合适的HTTP请求参数。例如，如果需要传递一些简单的参数，可以使用查询参数；如果需要传递一些复杂的参数或数据，可以使用请求体；如果需要指定请求的一些元数据信息，可以使用请求头。同时，还应该注意HTTP请求参数的编码方式，避免出现乱码等问题。\nHTTP响应 HTTP响应是服务器返回给客户端的信息，通常包括三个部分：状态行、响应头和响应体。\n状态行 状态行包含三个字段，分别是HTTP版本号、状态码和状态码的原因短语。例如：\n1 HTTP/1.1 200 OK 表示使用HTTP/1.1协议，状态码为200，状态码的原因短语为OK。\n常见的状态码及其含义：\n200 OK：请求成功，服务器返回请求的资源。 301 Moved Permanently：请求的资源已永久移动到新的URI。 302 Found：请求的资源已临时移动到新的URI。 400 Bad Request：请求有语法错误或请求参数不正确。 401 Unauthorized：请求未经授权。 403 Forbidden：请求被服务器拒绝。 404 Not Found：请求的资源未找到。 500 Internal Server Error：服务器内部错误。 响应头 响应头包含一系列键值对，描述了响应的元数据，例如服务器类型、数据格式等。常见的响应头字段及其含义：\nContent-Type：响应的数据类型，例如text/html、application/json等。 Content-Length：响应体的长度。 Server：服务器类型，例如Apache、Nginx等。 Set-Cookie：设置客户端的cookie。 Expires：过期时间，例如Tue, 01 Jan 2030 00:00:00 GMT。 响应头的格式如下：\n1 Key: Value 例如：\n1 2 Content-Type: application/json Server: Apache/2.4.41 (Ubuntu) 响应体 响应体包含了实际的数据内容，例如HTML、JSON等格式的文本数据，或者二进制数据等。\n例如，请求一个返回JSON格式数据的接口，服务器返回的响应体中包含了用户信息：\n1 2 3 4 5 { \u0026#34;id\u0026#34;: 123, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 18 } 在使用HTTP请求时，需要对响应状态码、响应头和响应体进行处理，根据实际需求进行解析和转换。\n","date":"2022-11-20T00:00:00Z","image":"https://slothhuman.github.io/img/purple.jpg","permalink":"https://slothhuman.github.io/p/%E8%AF%A6%E8%A7%A3http%E8%AF%B7%E6%B1%82/","title":"详解HTTP请求"},{"content":"简介 在Spring框架中，@RequestParam、@RequestBody、@PathVariable是常用的注解之一。这些注解可以用于控制器（Controller）中的方法参数，方便处理HTTP请求。本文将分别介绍这三个注解的使用方法、原理、代码示例以及它们之间的对比不同。\n@RequestParam注解 使用方法 @RequestParam注解用于将HTTP请求中的参数绑定到控制器方法的参数上。在使用@RequestParam注解时，可以设置参数名、是否必须、默认值等属性。\n示例代码如下：\n1 2 3 4 @GetMapping(\u0026#34;/user\u0026#34;) public User getUser(@RequestParam(\u0026#34;id\u0026#34;) Long id) { return userService.getUserById(id); } 在上面的示例中，@RequestParam注解绑定了请求参数中名为\u0026quot;id\u0026quot;的参数到getUser()方法的id参数上。\n原理 当Spring Boot应用程序接收到一个HTTP请求时，Spring框架将请求参数解析为一个名-值对的映射。在控制器方法上使用@RequestParam注解时，Spring框架会自动将请求参数的值与控制器方法的参数绑定起来。\n代码示例 1 2 3 4 5 6 7 @GetMapping(\u0026#34;/user\u0026#34;) public User getUser(@RequestParam(\u0026#34;id\u0026#34;) Long id, @RequestParam(value = \u0026#34;name\u0026#34;, required = false, defaultValue = \u0026#34;Guest\u0026#34;) String name) { User user = userService.getUserById(id); user.setName(name); return user; } 在上面的示例中，我们使用@RequestParam注解绑定了两个请求参数。\u0026ldquo;id\u0026quot;参数是必须的，而\u0026quot;name\u0026quot;参数是可选的。如果请求中没有传递\u0026quot;name\u0026quot;参数，则默认值为\u0026quot;Guest\u0026rdquo;。\n@RequestBody注解 使用方法 @RequestBody注解用于将HTTP请求体绑定到控制器方法的参数上。在使用@RequestBody注解时，我们需要指定请求体的数据类型。\n示例代码如下：\n1 2 3 4 @PostMapping(\u0026#34;/user\u0026#34;) public User createUser(@RequestBody User user) { return userService.createUser(user); } 在上面的示例中，@RequestBody注解绑定了请求体中的数据到createUser()方法的user参数上。\n原理 当Spring Boot应用程序接收到一个HTTP请求时，Spring框架将请求体解析为一个Java对象。在控制器方法上使用@RequestBody注解时，Spring框架会自动将请求体中的数据绑定到控制器方法的参数上。\n代码示例 1 2 3 4 5 @PostMapping(\u0026#34;/user\u0026#34;) public User createUser(@RequestBody User user) { User savedUser = userService.createUser(user); return savedUser; } 在上面的示例中，我们使用@RequestBody注解绑定了请求体中的数据到User对象上。Spring框架会自动将请求体中的数据解析为一个User对象，并将其绑定到createUser()方法的user参数上。\n@PathVariable注解 使用方法 @PathVariable注解用于将URL中的参数绑定到控制器方法的参数上。在使用@PathVariable注解时，需要在注解中指定URL中的参数名。\n示例代码如下：\n1 2 3 4 @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User getUser(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return userService.getUserById(id); } 在上面的示例中，@PathVariable注解绑定了URL中名为\u0026quot;id\u0026quot;的参数到getUser()方法的id参数上。\n原理 当Spring Boot应用程序接收到一个HTTP请求时，Spring框架将请求URL解析为一个名-值对的映射。在控制器方法上使用@PathVariable注解时，Spring框架会自动将URL中的参数值与控制器方法的参数绑定起来。\n代码示例 1 2 3 4 5 @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User getUser(@PathVariable(\u0026#34;id\u0026#34;) Long id) { User user = userService.getUserById(id); return user; } 在上面的示例中，我们使用@PathVariable注解绑定了URL中的\u0026quot;id\u0026quot;参数到getUser()方法的id参数上。Spring框架会自动将URL中的\u0026quot;id\u0026quot;参数值绑定到id参数上，并调用getUser()方法返回相应的用户对象。\n需要注意的是，@PathVariable注解也可以使用默认值和正则表达式等属性，以适应更多的场景。\n1 2 3 4 5 6 7 @GetMapping(\u0026#34;/user/{id:[\\\\d]+}\u0026#34;) public User getUser(@PathVariable(name = \u0026#34;id\u0026#34;, required = true) Long id, @PathVariable(name = \u0026#34;name\u0026#34;, defaultValue = \u0026#34;Guest\u0026#34;) String name) { User user = userService.getUserById(id); user.setName(name); return user; } 在上面的示例中，我们使用正则表达式指定了\u0026quot;id\u0026quot;参数必须为数字，使用了required属性确保\u0026quot;id\u0026quot;参数必须存在。同时，我们使用了defaultValue属性，以便在\u0026quot;name\u0026quot;参数未指定时使用默认值\u0026quot;Guest\u0026quot;。\n对比不同 @RequestParam和@PathVariable都用于将请求参数绑定到控制器方法的参数上，但是它们的作用方式不同。@RequestParam注解绑定的参数是在请求参数中指定的，而@PathVariable注解绑定的参数是在请求URL中指定的。\n@RequestBody注解用于将HTTP请求中的请求体绑定到方法参数上。请求体可以是JSON、XML、二进制数据等类型，与@RequestParam和@PathVariable不同，@RequestBody注解绑定的参数不是单个值，而是整个请求体。\n综上所述，@RequestParam、@RequestBody、@PathVariable这三个注解在实际应用中各有所用，具体使用哪一个取决于控制器方法所需的参数类型和参数来源。\n","date":"2022-11-09T00:00:00Z","image":"https://slothhuman.github.io/img/yes.jpg","permalink":"https://slothhuman.github.io/p/%E8%AF%A6%E8%A7%A3@requestparam@requestbody@pathvariable/","title":"详解@RequestParam、@RequestBody、@PathVariable"}]