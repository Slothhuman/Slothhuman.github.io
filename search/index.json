[{"content":"大表优化 限定数据的范围 读/写分离 拆分数据库 表拆分 垂直分区\n⽔平分区\n客户端代理 中间件代理 子主题 4 子主题 5 ","date":"2023-02-06T00:00:00Z","image":"https://slothhuman.github.io/img/22.jpg","permalink":"https://slothhuman.github.io/p/mysql%E4%B8%83%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96/","title":"MySQL（七）大表优化"},{"content":"索引 B+Tree索引 哈希索引 ","date":"2023-02-05T00:00:00Z","image":"https://slothhuman.github.io/img/21.jpg","permalink":"https://slothhuman.github.io/p/mysql%E5%85%AD%E7%B4%A2%E5%BC%95/","title":"MySQL（六）索引"},{"content":"锁 表级锁 粒度大 资源消耗少 加锁快 触发锁冲突概率最高 没有死锁 并发低\n行级锁 粒度小 加锁开销大 加锁慢 并发度高 会出现死锁\nRecord lock：单个⾏记录上的锁 Gap lock：间隙锁，锁定⼀个范围，不包括记录本身 Next-key lock：record+gap 锁定⼀个范围，包含记录本身 ","date":"2023-02-04T00:00:00Z","image":"https://slothhuman.github.io/img/20.jpg","permalink":"https://slothhuman.github.io/p/mysql%E4%BA%94%E9%94%81/","title":"MySQL（五）锁"},{"content":"事务 概念 事务是逻辑上的一组操作，要么都执行，要么都不执行 特性 原子性 隔离性 持久性 一致性 并发事务的问题 脏读\n丢失修改\n不可重复读\n重点是修改 幻读\n重点是新增或者删除 隔离级别 READ-UNCOMMITTED(读取未提交)\n可能导致脏读、不可重复读、幻读 READ-COMMITTED(读取已提交)\n可能导致不可重复读、幻读 REPEATABLE-READ(可重复读)\n可能导致幻读 SERIALIZABLE(可串⾏化)\n","date":"2023-02-03T00:00:00Z","image":"https://slothhuman.github.io/img/19.jpg","permalink":"https://slothhuman.github.io/p/mysql%E5%9B%9B%E4%BA%8B%E5%8A%A1/","title":"MySQL（四）事务"},{"content":"存储引擎 存储引擎基于表的，因此同一数据库内的不同表可以选择不同的存储引擎\nInnoDB 支持行级锁与表级锁，默认为行级锁\n支持事务与崩溃后的安全恢复\n支持外键\n支持MVCC\n实现\n隐藏字段\ntrx_id（6字节）\n每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给DB_TRX_ID隐藏列。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除 roll_pointer（7字节）\n回滚指针，指向该行的 undo log 。如果该行未被更新，则为空。 每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，任何通过回滚指针找到该记录修改前的信息。 row_id（6字节）\n如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引 Read View\n概念\n某个具体事务在使用MVCC机制进行快照读操作时产生的读视图 字段\nm_creator_trx_id\n创建该 Read View 的事务 ID m_low_limit_id\n目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见 m_up_limit_id\n活跃事务列表 m_ids 中最小的事务 ID，如果 m_ids 为空，则 m_up_limit_id 为 m_low_limit_id。小于这个 ID 的数据版本均可见 m_ids\nRead View 创建时其他未提交的活跃事务 ID 列表。创建 Read View时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。m_ids 不包括当前事务自己和已提交的事务（正在内存中） 隔离级别\nRC（读已提交）\n在 RC 隔离级别下的 每次select 查询前都生成一个Read View (m_ids 列表) RR（可重复读）\n在 RR 隔离级别下只在事务开始后 第一次select 数据前生成一个Read View（m_ids 列表） undo log版本链\n概念\n对记录每次更新后， 两个作用\n当事务回滚时用于将数据恢复到修改前的样子 另一个作用是 MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 undo log 读取之前的版本数据，以此实现非锁定读 分类\ninsert undo log\n指在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对其他事务不可见，故该 undo log 可以在事务提交后直接删除。不需要进行 purge 操作 update undo log\nupdate 或 delete 操作中产生的 undo log。该 undo log可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge线程 进行最后的删除 MySQL InnoDB默认的隔离级别可以解决幻读\n快照读（非一致性锁定读）：由 MVCC （对非锁定读的实现）机制来保证不出现幻读。\n快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。 在 RC （读已提交）级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据 在 RR （可重复读）级别下，对于快照数据，非一致性读总是读取本事务开始时的行数据版本 当前读 （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。\n索引\n数据⽂件本身就是按B+Tree组织的⼀个索引结构 聚集索引是通过主键查找数据。而辅助索引先通过Key查找主键，然后再走一遍聚集索引 MyISAM 支持表级锁\n索引\n索引⽂件和数据⽂件是分离的 B+Tree叶节点的data域存放的是数据记录的地址，先根据Key取出data域的值，然后通过data域的值（即地址）读取相应的数据记录。这被称为“⾮聚簇索引” ","date":"2023-02-01T00:00:00Z","image":"https://slothhuman.github.io/img/18.jpg","permalink":"https://slothhuman.github.io/p/mysql%E4%B8%89%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","title":"MySQL（三）存储引擎"},{"content":"SQL语句执行 连接器： 身份认证和权限相关(登录 MySQL 的时候) 查询缓存: 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用） 查询缓存前需要校验用户的权限，看是否能查询该表 分析器: 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。 词法分析\n提取SQL语句中的关键字 语法分析\n判断语法是否正确 优化器： 按照 MySQL 认为最优的方案去执行 比如多个索引时如何选择索引，多表查询时如何选择关联顺序 执行器: 执行语句，然后从存储引擎返回数据 执行前校验用户是否有权限，如果有权限则去调用引擎接口 一条SQL语句执行很慢 一直很慢\n没有用索引\n1.可能该字段没有索引 2.由于对字段进行运算或者函数操作导致索引无法使用 3.由于统计错误，系统不走索引而走了全表扫描 偶尔很慢\n数据库在刷新脏页\n可能redo log写满了需要刷到磁盘上 一次性查询比较多的数据，恰好这些数据不在内存上，恰好内存不够了需要淘汰一部分数据页，如果是干净页就直接释放，如果恰好是脏页就需要刷脏页 MySQL认为系统“空闲”的时候 MySQL正常关闭时 执行时遇到锁了，需要等待\n","date":"2023-01-31T00:00:00Z","image":"https://slothhuman.github.io/img/17.jpg","permalink":"https://slothhuman.github.io/p/mysql%E4%BA%8Csql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C/","title":"MySQL（二）SQL语句执行"},{"content":"基础架构 连接器 管理连接，身份验证、权限验证 查询缓存 命中缓存，直接返回 分析器 词法分析，语法分析 优化器 选择最优执行方案，，选择索引 执行器 操作引擎，返回结果 插件式存储引擎 存储数据，提供读写接口 ","date":"2023-01-29T00:00:00Z","image":"https://slothhuman.github.io/img/16.jpg","permalink":"https://slothhuman.github.io/p/mysql%E4%B8%80%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/","title":"MySQL（一）基础架构"},{"content":"Java的自动内存管理 Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收\nJVM内存分配 策略\n对象a优先在eden区分配\n1.若eden区原本有对象b，且有足够的空间，则分配在eden区 2.若eden区没有足够的空间进行分配，虚拟机将发起Minor GC，将对象b存入Survivor空间 3.如果如果对象b无法存入Survivor空间中，则通过分配担保机制存入老年代 4.如果老年代没有足够的空间存入对象b，则执行Full GC，总之让eden区有足够的内存存入对象a 大对象直接进入老年代\n需要大量连续内存空间的对象，比如字符串、数组 好处：了避免为⼤对象分配内存时由于分配担保机制带来的复制⽽降低效率 长期存活的对象将进入老年代\n给每个对象一个年龄计数器，对象每在Survivor区中存活过一次Minor GC，年龄+1；达到一定年龄（默认15）后进入老年代 如果Survivor空间中同一年龄的所有对象的总和大于Survivor空间的一半，则年龄大于等于该年龄的对象就可以直接进入老年代 JVM内存回收 引用\n强引⽤(StrongReference)\n必不可少，当内存空间不⾜，Java虚拟机 宁愿抛出OutOfMemoryError错误，也不回收 软引⽤(SoftReference)\n如果一个对象只有软引用，当内存空间不⾜了，就会回收这些对象的内存 可以和⼀个引⽤队列（ReferenceQueue）联合使⽤ 一般用软引用比较多，软引⽤可以加速JVM对垃圾内存的回收速度，可以维护系统的运⾏安全，防⽌内存溢出（OutOfMemory）等问题的产⽣。 弱引⽤(WeakReference)\n垃圾回收器一旦发现弱引用，不管内存空间是否充足，都回收 可以和⼀个引⽤队列（ReferenceQueue）联合使⽤ 虚引⽤（PhantomReference）\n主要⽤来跟踪对象被垃圾回收的活动 如果一个对象有虚引用，那么回收它之前必须将虚引用加入到引用队列 废弃常量\n运行时常量池来回收 当前没有任何对象来引用此常量，则为废弃 无用的类\n该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例 加载该类的 ClassLoader 已经被回收 该类对应的 java.lang.Class 对象没有在任何地⽅被引⽤，⽆法在任何地⽅通过反射访问该类 的⽅法 对象是否死亡\n引⽤计数法\n缺点是不能解决对象之间相互循环引用的问题 可达性分析算法\n概念\n找到一系列被称为“GC roots”的对象作为起点，从这些节点向下遍历，走过的路径称为引用链，当一个对象到“GC roots”没有任何一条引用链相连，则说明这个对象不可用 步骤\n该算法的全过程都需要基于一个能保障一致性的快照中才能够分析，这意味着必须全程冻结用户线程的运行 1.根节点枚举 2.向下遍历对象图 GC roots\n虚拟机栈中引用的对象 本地方法栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 所有被同步锁持有的对象 经过可达性分析为不可达的对象并不会马上回收，需要经过两次标记才可以宣告死亡\nGC\n对象晋升老年代\n1.动态对象年龄判断机制\n2.新生代垃圾回收之后，存活对象太多，导致大量对象直接进入老年代\n3.大对象直接进入老年代\n4.对象躲过了15次垃圾回收（默认），进入老年代\n5.空间担保机制\n当要MinorGC之前，首先会计算老年代剩余空间是否大于新生代所有对象大小之和(防止极端情况下eden区所有对象都幸存)。 2.如果剩余空间不够放全部的新生代对象，但是配置了-XX:-HandlePromotionFailure参数（1.6以后废弃），那么就会计算每次MinorGC后存活对象的平均大小，如果老年代剩余内存大小大于这个平均大小，则大胆认为这次MinorGC回收后，老年代还是可以放得下 如果该次MinorGC之后老年代的确是放不下就进行Fulll GC，如果Full GC完了还是放不下则oom 行为\n部分收集 (Partial GC)\n新⽣代收集（Minor GC / Young GC）\n当eden区内存分配满了时，触发Young GC，然后会有部分对象进入老年代，老年代内存占用会提高 ⽼年代收集（Major GC / Old GC）\n混合收集（Mixed GC）\n整堆收集 (Full GC)\n当准备触发新生代收集时，如果发现统计数据说之前Young GC的平均晋升大小比目前老年代剩余的空间大，则不会触发Young GC而是转而触发Full GC。 老年代空间不足 永久代空间不足：如果有Perm Gen，要在Perm Gen分配空间但已经没有足够的空间时，触发一次Full GC 使用System.gc()，默认也是触发Full GC 由eden区向Survivor区复制时，对象大于Survivor内存，同时大于老年代可用空间，则触发Full GC 算法（内存回收的方法论）\n标记-清除算法\n分“标记”和“清除”阶段，先标记所有存活的对象，然后统一回收没有标记的对象 1.效率问题 2.空间问题（会产生大量不连续的碎片） 标记-复制算法\n每次对内存空间的一半进行回收 将内存分为两块，标记存活对象，将存活对象复制到另一块内存，然后把这块内存进行回收 标记-整理算法\n标记存活对象，把存活对象向一端移动，然后直接清理端边界以外的内存 分代收集算法\n根据对象存活周期不同将内存分为几块 新生代使用标记-复制算法，老年代使用标记-清除算法或者标记-整理算法 分代主要是为了提升GC效率 垃圾回收器（内存回收的具体实现）\nSerial收集器\n新生代采用复制算法，老年代采用标记-整理算法 单线程 简单高效 ParNew收集器\nSerial收集器的多线程版本 Serial Old 收集器\nSerial收集器的老年代版本 单线程 Parallel Scavenge收集器\n新生代采用复制算法，老年代采用标记-整理算法\n多线程\n关注点是吞吐量（⾼效率的利⽤ CPU）\n吞吐量就是 CPU 中⽤于运⾏⽤户代码 的时间与 CPU 总消耗时间的⽐值 JDK1.8 默认使⽤的是 Parallel Scavenge + Parallel Old\nParallel Old 收集器\nParallel Scavenge收集器的老年代版本 多线程 CMS收集器\n关注点更多的是⽤户线程的停顿时间（提⾼⽤户体验）\n标记-清除算法\n过程\n初始标记\n并发标记（基于增量更新来做的）\n特点\n垃圾回收器和用户线程同时运行，并发工作 三色标记法\n在遍历对象图的过程中，把访问都的对象按照\u0026quot;是否访问过\u0026quot;这个条件标记成以下三种颜色\n白色\n表示对象尚未被垃圾回收器访问过 灰色\n表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过。 黑色\n表示对象已经被垃圾回收器访问过，且这个对象的所有引用都已经扫描过 解决的问题\n减少STW，主要是减少从GC roots节点往下遍历对象图并进行标记这一过程的停顿时间 带来了问题\n浮动垃圾\n产生原因\n垃圾回收器在工作时，用户线程在同时修改引用关系，把原本应该回收的对象修改为存活的 解决方法\n下次清理 对象消失\n产生原因\n垃圾回收器在工作时，用户线程在同时修改引用关系，把原本应该存活的对象修改为回收的 解决方法\n增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB） 重新标记\n并发清除\n优点\n并发、低停顿 缺点\n1.对CPU资源敏感 2.无法处理浮动垃圾 使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生 G1收集器\n面向服务器，主要针对配备多颗处理器及大容量内存的机器\n过程\n初始标记 并发标记 最终标记 筛选回收 特点\n1.并发与并行\n2.分代收集\n3.空间整合\n整体看是标记-整理算法实现 局部看是标记-复制算法 4.可预测的停顿\nZGC 收集器\n标记-复制算法 位置\nJVM的GC并不是任何时刻都发生的，只有STW，才会执行GC\n安全点\n概念\n程序执行时并非在所有地方都能停顿下来开始GC ， 只有在特定的位置才能停顿下来开始GC ， 这些位置称为“ 安全点（Safepoint）。 GC时线程的中断策略\n抢先式中断 主动式中断 选择\n循环的末尾 方法临返回前 调用方法之后 抛异常的位置 安全区\n概念\n安全区域是指在一段代码片段中， 对象的引用关系不会发生变化， 在这个区域中的任何位置开始GC 都是安全的。我们也可以把Safe Region 看做是被扩展了的Safepoint 执行流程\n1 、当线程运行到 Safe Region 的代码时， 首先标识己经进入了safe Region ，如果这段时间内发生GC ,JVM会忽略标识为 Safe Region 状态的线程(认为它是安全的) 2.当线程即将离开时， 会检查JVM是否己经完成GC ， 如果完成 ， 则继续运行， 否则线程必须等待直到收到可以安全离开Safe Region 的信号为止 ","date":"2023-01-28T00:00:00Z","image":"https://slothhuman.github.io/img/14.jpg","permalink":"https://slothhuman.github.io/p/jvm%E5%9B%9Bjava%E7%9A%84%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"JVM（四）Java的自动内存管理"},{"content":"Java内存区域 线程私有 程序计数器\n作用\n字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执 ⾏、选择、循环、异常处理 在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时 候能够知道该线程上次运⾏到哪⼉了 程序计数器是唯⼀⼀个不会出现OutOfMemoryError 的内存区域\n随着线程的创建⽽创建，随着线程的死亡⽽死亡\n虚拟机栈\n栈帧\n局部变量表\n主要存放编译期可知的各种数据类型与对象引用 操作数表\n动态链接\n方法出口信息\n错误\nStackOverFlowError 和 OutOfMemoryError 随着线程的创建⽽创建，随着线程的死亡⽽死亡\n返回方式\nreturn语句和抛出异常 虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节 码）服务\n本地方法栈\n本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务 线程共享 堆\n作用\n存放对象实例，⼏乎所有的对象实例以及数组都在这⾥分配内存。 从jdk 1.7开始已经默认开启逃逸分析，如果某些⽅法中的对象引⽤没有被返回或者未被外⾯使⽤（也就是未逃逸出去），那么对象可以直接在栈上分配内存 OutOfMemoryError\n基本结构（JDK1.7）\n新生代\nEden区 Survivor区 老年代\n永久代\n方法区\n实现\nJDK 7 版本及JDK 7 版本之前，永生代\nJVM 本身设置固定⼤⼩上限，⽆法进⾏调整 JDK 8 版本之后，元空间\n直接内存，受本机可⽤内存的限制 运行时常量池\nJDK1.7之前存放在方法区 JDK1.7存放在方法区，但字符串常量池被拿到堆中 JDK1.8存放在方法区，但字符串常量池被拿到堆中，方法区实现变成元空间 主要⽤于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n直接内存 (⾮运⾏时数据区的⼀部分)\n元空间 OutOfMemoryError ","date":"2023-01-27T00:00:00Z","image":"https://slothhuman.github.io/img/13.jpg","permalink":"https://slothhuman.github.io/p/jvm%E4%B8%89java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","title":"JVM（三）Java内存区域"},{"content":"类 类文件结构 魔数\nClass文件的标志 Class文件版本号\n常量池\n访问标志\n当前类\n字段表集合\n方法表集合\n属性表集合\n类的生命周期 类加载过程\nClass 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢\n加载\n1.通过全类名获取定义此类的二进制字节流\n比如：比较常见的就是从 ZIP 包中读取（日后出现的 JAR、EAR、WAR 格式的基础）、其他文件生成（典型应用就是 JSP）等等 非数组类我们可以去自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法） 数组类型不通过类加载器创建，它由 Java 虚拟机直接创建 2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构\n3.在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口\n连接\n验证\n文件格式验证 元数据验证 字节码验证 符号引用验证 准备\n准备阶段是正式为类变量（即静态变量）分配内存并设置类变量初始值（数据类型默认的零值）的阶段，这些内存都将在方法区分配 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中 解析\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程 初始化\n必须对类进行初始化的情况\n当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时 使用 java.lang.reflect 包的方法对类进行反射调用时如 Class.forname(\u0026quot;\u0026hellip;\u0026quot;), newInstance() 等等。如果类没初始化，需要触发其初始化 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类 MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化 使用\n卸载\n卸载类即该类的 Class 对象被 GC\n满足3个要求即可卸载类\n该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。 该类没有在其他任何地方被引用 该类的类加载器的实例已被 GC ","date":"2023-01-26T00:00:00Z","image":"https://slothhuman.github.io/img/12.jpg","permalink":"https://slothhuman.github.io/p/jvm%E4%BA%8C%E7%B1%BB/","title":"JVM（二）类"},{"content":"Java对象 Java对象创建 1.类加载检查\n虚拟机遇到new指令，检查这个类之前是否加载过，若没有就执行类加载检查 2.分配内存\n分配方式\n指针碰撞 空闲列表 选择哪种方式由Java堆是否规整决定，⽽ Java 堆内存是否规整，取决于GC 收集器的算法是\u0026quot;标记-清除\u0026quot;，还是\u0026quot;标记-整理\u0026quot;（也称作\u0026quot;标记-压缩\u0026quot;）\n3.初始化零值\n4.设置对象头\n5.执行init方法\n对象访问定位 句柄\nJava堆中划分一块内存作为句柄池，句柄池中包含“到对象实例数据的指针”和“到对象类型数据的指针”，reference存储对象的句柄地址。 假如对象移动时，reference存储对象的句柄地址不需要改变 直接指针\n对象中包含“对象实例数据”和“到对象类型数据的指针”，⽽reference 中存储的直接就是对象的地址。 速度快，节省了⼀次指针定位的时间开销 ","date":"2023-01-25T00:00:00Z","image":"https://slothhuman.github.io/img/11.jpg","permalink":"https://slothhuman.github.io/p/jvm%E4%B8%80java%E5%AF%B9%E8%B1%A1/","title":"JVM（一）Java对象"},{"content":"Map Key 是⽆序的、不可重复的，value 是⽆序的、可重复 的，每个键最多映射到⼀个值\nHashMap 非线程安全\n效率比Hashtable高一点\nHashMap 可以存储 null 的 key 和 value，但 null 作为 键只能有⼀个，null 作为值可以有多个\n初始大小和扩容量大小\n创建时如果不指定容量初始值\nHashMap 默认的初始化⼤⼩为 16。之后每次扩充，容量变为原来的 2 倍。 创建时如果给定了容量初始值\nHashMap 会将其扩充为 2 的幂次⽅⼤⼩ 底层数据结构\nJDK1.8之前\n底层是 数组和链表 JDK1.8\n当链表⻓度⼤于阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链表转化为红⿊树，以减少搜索时间 HashTable 线程安全\nHashTable 内部的⽅法基本都经过 synchronized 修饰 HashTable基本被淘汰\nHashTable 不允许有 null 键和 null 值，否则会抛出NullPointerException\n初始大小和扩容量大小\n创建时如果不指定容量初始值\n默认初始化大小为11，之后每次扩充，容量变为原来的2n+1 创建时如果给定了容量初始值\n直接使用给定的大小 子主题 5\n","date":"2023-01-23T00:00:00Z","image":"https://slothhuman.github.io/img/10.jpg","permalink":"https://slothhuman.github.io/p/java%E9%9B%86%E5%90%88%E4%BA%8Cmap/","title":"Java集合（二）Map"},{"content":"List List (对付顺序的好帮⼿)： 存储的元素是有序的、可重复的\nArraylist 不保证线程安全\n底层数据结构是Object数组\n采用数组存储\n插入和删除元素的时间复杂度受元素位置影响\n插入数组末尾 O(1) 插入指定位置 O(n-i) 支持高效的随机元素访问\n通过数组下标访问 空间占用\nlist 列表的结尾会预留⼀定的容量空 间 所实现的接口\nList\nRandomAccess\n标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的 Cloneable\njava.io.Serializable\n扩容机制\nadd()\n第一次扩容成10，后面每一次扩容成之前的1.5倍\n以无参构造函数创建ArrayList时，创建的是空数组 当向数组中添加第一个元素，则数组会扩容为10 当添加到第11个元素时，则再次扩容为15，即10+（10\u0026raquo;1） addAll()\naddAll(Collection c)没有元素时，扩容为Math.max(10,实际元素长度) 有元素时，扩容为Math.max(原容量的1.5倍，实际元素长度)\n以无参构造函数创建ArrayList时，创建的是空数组 向数组中添加11个元素，则直接扩容成11 LinkedList 线程不安全\n底层数据结构是双向链表\n链表存储\n插入删除元素的时间复杂度不受元素位置影响。O(1) 但是如果在指定位置插入就有影响 O(n) 不支持高效的随机访问\n空间占用\n元素需要存放直接后继、直接前驱、数据 Vector 底层数据结构是Object数组 线程安全 ","date":"2023-01-21T00:00:00Z","image":"https://slothhuman.github.io/img/9.jpg","permalink":"https://slothhuman.github.io/p/java%E9%9B%86%E5%90%88%E4%B8%80list/","title":"Java集合（一）List"},{"content":"内存管理 内存管理主要是做什么 内存的分配与回收 地址转换即将逻辑地址转换成相应的物理地址 内存管理方式 连续分配管理方式\n块式管理 非连续分配管理方式\n页式管理\n页式管理通过页表对应逻辑地址和物理地址\n页是物理单位\n页与页之间是离散的，页中的内存是连续的\n快表\n为了提高虚拟地址到物理地址的转换速度 多级页表\n时间换空间 段式管理\n段式管理通过段表对应逻辑地址和物理地址。 段是有实际意义的，每个段定义了一组逻辑信息 段与段之间是离散的，段中的内存是连续的 段页式管理\n逻辑（虚拟）地址与物理地址 逻辑地址\nC 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定\n优势\n可以用一系列相邻的虚拟内存来代表物理内存中不相邻的大内存缓冲区，然后访问 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存 物理地址\n物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址\n不足\n如果直接把物理地址暴露出来的话会带来严重问题 虚拟内存（时间换空间） 虚拟内存是计算机系统管理内存的一种技术\n虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）\n虚拟内存的重要意义是它定义了一个连续的虚拟内存空间，并把内存扩展到了硬盘空间\n实现方式\n请求分页存储管理 请求分段存储管理 请求段页式存储管理 页面置换算法\nOPT 页面置换算法（最佳页面置换算法） FIFO（First In First Out） 页面置换算法（先进先出页面置换算法） LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法） LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法） ","date":"2023-01-19T00:00:00Z","image":"https://slothhuman.github.io/img/8.jpg","permalink":"https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"操作系统（四）内存管理"},{"content":"线程 状态 NEW（新建）\n线程刚刚创建的状态 READY（就绪）\n调用start()方法后 RUNNABLE（运⾏中）\n获得时间片后 WAITING（等待）\n执行wait()后进入等待，执行notify()后回到可运行 TIME_WAITING(超时等待)\n执行wait(long)或者sleep(long)后进入超时等待，时间到或者notify()后回到可运行状态 BLOCKED（阻塞）\n调用同步方法时，在没有获得锁的情况下就会阻塞,获得锁后又回到可运行状态 TERMINATED（终⽌）\n执行run()后 线程间同步的方式 互斥量\n互斥对象机制 信号量\n事件\n多线程 可能带来的问题\n内存泄露 上下文切换 死锁 多线程使用原因\n计算机底层\n资源的花销\n多核CPU时，多个线程可以同时运行，减少了线程上下文切换的开销 线程量级较小，线程间的切换和调度成本远小于进程 CPU\n单核\n此时多线程是为了提高CPU和IO设备的综合利用率\n即CPU工作时不能让IO设备闲着 多核\n此时是为了提高CPU的利用率\n有多个CPU，这个CPU工作时，不能让其他CPU闲着 当代互联网发展趋势\n系统要求的并发量非常高，利用多线程可以提供系统的并发能力 ","date":"2023-01-18T00:00:00Z","image":"https://slothhuman.github.io/img/5.jpg","permalink":"https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%E7%BA%BF%E7%A8%8B/","title":"操作系统（三）线程"},{"content":"进程 状态 创建状态\n就绪状态\n一旦得到处理器分配的时间片就可以运行 运行状态\n进程正在处理器上运行 阻塞状态\n结束状态\n进程间通信方式 管道/匿名管道\n父子进程或兄弟进程 只存在于内存中的文件 有名管道\n先进先出 以磁盘文件的方式存在 信号\n消息队列\n通信数据先进先出 存放在内核中 信号量\n共享内存\n套接字\n调度算法 先到先服务调度算法\n给最快进入就绪队列的进程分配资源 短作业优先调度算法\n选出一个估计运行时间最短的进程，给它分配资源 时间片轮转调度算法\n给每个进程分配时间片 多级反馈队列调度算法\n优先级调度\n死锁 概念\n多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止 产生死锁的四个必要条件\n互斥\n资源为非共享，即一次只能由一个线程使用 占用并等待\n非抢占\n循环等待\n解决死锁的方法\n预防\n概念\n采用某种策略，限制并发进程对资源的请求，使得死锁的必要条件不满足，破坏四大必要条件中的一个就行 方法\n破坏“占用并等待”\n静态分配策略 破坏“循环等待”\n层次分配策略 避免\n概念\n在系统分配资源时，根据资源的使用情况做出预测，从而避免死锁的发生（允许四大必要条件同时存在） 方法\n银行家算法判断系统是否处于安全状态 检测\n系统定时地运行一个“死锁检测”程序 解除\n方法\n立即结束所有进程的执行，重新启动操作系统 撤销涉及死锁的所有进程，解除死锁后继续运行 逐个撤销涉及死锁的进程，回收其资源直至死锁解除 抢占资源 ","date":"2023-01-17T00:00:00Z","image":"https://slothhuman.github.io/img/6.jpg","permalink":"https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%E8%BF%9B%E7%A8%8B/","title":"操作系统（二）进程"},{"content":"基础 系统调用 设备管理 文件管理 进程控制 进程通信 内存管理 ","date":"2023-01-15T00:00:00Z","image":"https://slothhuman.github.io/img/4.jpg","permalink":"https://slothhuman.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%80%E5%9F%BA%E7%A1%80/","title":"操作系统（一）基础"},{"content":"三个状态 每个人都有儿童、父母以及成年人的状态，三位一体，成年人之所以痛苦，恰恰是因为不在成人状态。\n苍鹭在蛤蟆先生咨询的过程中，将我们的人生分为：儿童、成人、父母三个状态。\n1、儿童自我状态。当一个人处于儿童自我状态时，他会下意识用童年时的习惯作出反应，表现出像孩子一样的感受和行为。在这种状态下，他会本能地顺从和依赖他人，再现过去的情形，体验过去压抑的痛苦情绪，学不到任何新的东西。\n2、父母自我状态。处在父母自我状态的人，不是在挑剔别人就是在挑剔自己。处在这种状态下的人，会用言行重复父母那里学到的是非观和价值观，想方设法让别人接受自己的这套想法。甚至会将审判的矛头指向自己，进行毫不留情的自我批判。\n3、成人自我状态。在成人自我状态的时候，我们能摆脱情绪化的控制，合理地计划、考虑、决定、行动，用知识和技能解决当下的事情。成人自我状态是唯一能学到自我新知识的状态，因为在儿童自我状态里，只是在体验过去的情绪，在父母自我状态里，不是挑剔就是在教育别人，所以这两种状态都不会学到东西。\n四个坐标 人生有四个坐标，你选择的坐标决定了你成为什么样的人，“你好我好”是我们奋斗的终极目标。\n苍鹭曾问过蛤蟆两个问题：第一个问题是：你是怎么看自己的？你好吗？第二个问题是：你是怎么看别人的？他好吗？\n根据这两个问题的回答，产生了以下四种人生坐标：\n1、你好，我不好。处在这个坐标的人认为自己是生活的受害者，无法掌控人生，从而产生焦虑、抑郁、自责等情绪。\n2、我好，你不好。处于这个坐标的人常常会占据权力和权威的制高点，时常攻击、指责别人，产生愤怒、挑剔、指责等情绪。\n3、我不好，你也不好。处于这个坐标的人更确切来说是“犯罪者”，既自卑又自大，既自我贬低也攻击他人，情绪反复无常，很容易产生报复社会的行为。\n4、你好，我也好。这不仅是一种状态，更是一种选择和承诺。你相信自己是好的，更相信别人是好的，通过行为和态度，持续对自己和别人展现美好。\n自我证言 假如认为自己是一个失败者，往往就会真的成为失败者，这应该是一种消极的心里暗示\n游戏 比如”我很弱小“游戏，玩家会从各方面去证明，让别人认同自己很可怜很弱小，有点像受害者心理。\n总结 每个人都有自己的内心世界和情感状态，只有通过认真倾听和探索，才能够发现自己真正的内心需求和意义。正视、接纳自己内心深处的想法和情感需求。\n不要自我批判，或对自己要求太过苛刻 能帮自己的只有自己，只有自己真正发自内心想去改变才能有所成效 ","date":"2023-01-14T00:00:00Z","image":"https://slothhuman.github.io/img/15.jpg","permalink":"https://slothhuman.github.io/p/%E8%9B%A4%E8%9F%86%E5%85%88%E7%94%9F%E5%8E%BB%E7%9C%8B%E5%BF%83%E9%87%8C%E5%8C%BB%E7%94%9F%E8%AF%BB%E5%90%8E%E8%AE%B0%E5%BD%95/","title":"《蛤蟆先生去看心里医生》读后记录"},{"content":"技术改变世界 随着技术的不断进步，它已经成为了改变世界的一个强大工具。无论是从商业、政治还是文化角度看，技术的进步都对人类产生了深远的影响。书中提到了很多令人震撼的案例，比如谷歌搜索引擎、苹果公司的iPhone，以及无人驾驶汽车等等。这些人通过他们的技术创新和创意，成功地改变了我们的世界。\n天才程序员通过开发软件和硬件来解决现实世界中的问题，从而创造出新的商业模式和产品，影响着我们的日常生活。技术的进步带来便利的同时也会带来许多新的问题和挑战，例如隐私和安全问题，以及人工智能对就业的影响等等。这些问题需要我们思考和解决。程序员也应负起社会责任，在技术发展和应用中也需要考虑人类的利益和社会的可持续发展。\n四代程序员发展变化 编程语言：机器语言到高级编程语言（JAVA等）\n开发工具：大型计算机到个人计算机\n程序员：现代软件工程师需要具备更广泛的技术技能，如前端和后端开发、数据库管理和安全性等方面的知识。此外，现代软件工程师还需要了解如何与团队合作，如何管理项目和与客户进行沟通等技能。\n程序员的逻辑思维模式 极致的求真精神、强烈的好奇心和创新意识，创造力，以及敏锐的洞察力和分析能力。追求效率，厌恶重复低效的事情。\n程序员的性格特征 内向、喜欢独处和专注等等，这些特质在程序员工作中发挥了很大的作用。但是，这些特质也可能导致程序员们感到孤独和焦虑，特别是在面对技术难题时。\n程序员的焦虑抑郁状态 （工作环境、工作压力、工作不确定性、工作时长、缺乏社交，作息不规律）\n许多程序员患有抑郁症或者有严重的焦虑、狂躁情绪，也听说一些程序员因为饱受精神疾病的困扰最终自杀。很多人不禁好奇，编程是否和心理健康有着某种联系？\n折磨人的挫败感与突发的愉悦感相互交织，频繁变化，程序员的自尊也常常大幅波动。如果你恰好碰到某个程序员都3个星期了还没解决自己的程序问题，那么他肯定已经陷入极端郁闷和自我否定的状态，但可能一个小时后，问题就被解决了，他瞬间就会成为一个自高自大到无以复加的人。\n程序员心流状态 心流状态是一种高度集中和沉浸的状态，提高工作效率和创造力。这种状态可以提高程序员们的工作效率和满意度。过度追求心流状态也会让我们忽略身体健康和生活平衡，或许这也是程序员的焦虑抑郁状态的其中一个原因。\n程序员一旦进入状态，对整个程序的框架了然于心，编程会变得非常愉悦。整个人都沉浸其中，将个人技能发挥至极致。但是，这个状态非常脆弱，即使是最轻微的干扰也会让那小心翼翼形成的思维空间顷刻消失。\n程序员处在自己的状态中时，突然被人打断他们可能会暴跳如雷。他们好不容易在脑海里精心搭建起细密的框架结构，这时有人来了一句“嘿，你收到我发的邮件了吗”，他们脑海中的架构瞬间不复存在。\n程序员在工作的时候，会竭尽所能避开其他人，因为从本质上说，其他人就是干扰。有的程序员会戴上耳机，屏蔽一切噪声。有的程序员会把最复杂的工作留到夜深人静的时候，留到所有电话、短信、时政新闻都消停时再做。\n程序员代码重构精神 （不断地寻求更好的解决方案）\n越紧凑的代码质量越高，主要是因为代码的行数越少，出现程序错误的概率越小。程序错误很容易藏身于一大堆面条式代码中，而短小紧凑的代码更容易让人看出各处正常与否，就像桦树林，棵棵树木挺拔笔直，放眼望去一清二楚。\n重构和润色有一些相似之处。无论你是写信、写讲稿抑或写文章，第一稿总有些冗长或含糊，传达出了基本信息，却不够简洁明了，可能啰里啰唆，可能拐弯抹角，还可能逻辑不清。\n但是没关系，因为你的目标不是完美的，先写出来，稍后慢慢修改。润色的过程会让文意更清晰，让语言更真切，让絮絮叨叨的话语不复存在，让行文更紧凑有力。字斟句酌，精雕细琢，润色后的文本往往比初稿更简洁。\n程序员的开源精神 （开放与分享）\n在阅读这本书的过程中，我深刻感受到了开源精神所带来的巨大价值。作者通过讲述开源项目（例如Linux）的发展历程以及参与者的思考方式和精神状态，展现了开源精神对于技术进步和社会发展的巨大推动力。开源项目可以吸引全球的开发者参与其中，共同完成项目的开发和维护，这不仅可以让技术得到不断的完善，也可以为社会提供更加优质的产品和服务。\n此外，作者还深入探讨了开源精神对于创新的重要作用。在开源项目中，每个参与者都可以自由地贡献自己的思想和创意，这种协作方式不仅可以让项目得到更多的创新思路，也可以激发每个参与者的创造力和积极性。通过开源精神，我们可以打破原有的知识壁垒和传统思维，让更多的人参与到创新的过程中。\n在读完这本书之后，我更加认识到了开源精神对于技术和社会的发展所起到的作用。开源精神不仅可以促进技术进步和创新，也可以增强社会的协作和共同进步意识。这些精神也可以被应用到更广泛的领域中，为社会的发展带来更多的积极影响。\n程序员男性化 通过对历史和现实的案例分析，汤普森指出，程序员文化中的男性化现象源于社会文化环境的影响，如对男性的期望和刻板印象等。这种偏见会导致女性和其他少数族裔在技术领域中面临着更大的挑战和障碍，这种性别偏见不仅仅是一种歧视，更是一种威胁。因为它会让许多有天赋和潜力的女性和少数族裔放弃追求科技领域的职业，从而限制了创新和发展。\n人工智能 最近比较热门的聊天机器人ChatGPT，因其高效的语言处理能力备受关注。AI+行业正在重塑这个世界，有人对未来的AI充满期待，也有人对AI的发展充满担忧，认为可能成为人类的威胁。\n人工智能的崛起也带来了一些问题和挑战。例如，人工智能可能会替代一些传统行业的工作，导致失业和社会不平等；人工智能的算法也可能存在一些偏见和歧视，影响公正性和透明度。\n人工智能的发展和应用在未来的发展中需要平衡技术发展和社会责任，确保人工智能的应用能够为人类带来更多的利益和福祉。\n","date":"2023-01-10T00:00:00Z","image":"https://slothhuman.github.io/img/3.jpg","permalink":"https://slothhuman.github.io/p/%E5%A4%A9%E6%89%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%80%E6%9C%AF%E7%8B%82%E4%BA%BA%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C%E8%AF%BB%E5%90%8E%E8%AE%B0%E5%BD%95/","title":"《天才程序员：技术狂人如何改变世界》读后记录"},{"content":"什么是SDK调用方式 SDK调用方式是现代软件开发中常用的一种方式，它通过提供简单易用的接口，让开发者可以轻松地调用第三方API，避免了繁琐的HTTP请求和参数处理。使用SDK调用方式可以大大提高开发效率和代码可读性，同时也能够降低出错的风险。\n什么是SDK SDK全称为Software Development Kit，中文名为软件开发工具包，是一种为特定软件包、软件框架、硬件平台、操作系统等开发者提供的一系列工具的集合，它包含了开发所需的一些资源、API、文档、示例代码等。SDK的目的是简化开发者的工作，提供一些常用的开发工具和接口，使开发者能够快速地开发出满足业务需求的软件或应用。一些著名的SDK包括Android SDK、iOS SDK、AWS SDK等。\nSDK调用方式的特点 SDK调用方式是指使用第三方提供的SDK来调用其API，这种方式相对于直接调用API具有以下几个特点：\n封装性：SDK通常会对API进行封装，使得调用更加简单易用； 统一性：SDK提供了统一的接口和规范，可以方便地进行开发和维护； 兼容性：SDK通常会提供多种编程语言的版本，以便不同编程语言的开发者使用； 可靠性：SDK通常会对API进行错误处理和异常处理，提高调用的可靠性。 SDK调用方式的优势（使用别人的SDK） 使用SDK调用方式具有以下优势：\n提高开发效率：使用SDK可以避免开发者自己编写大量的代码来调用API，从而节省了时间和精力； 提高调用的可靠性：SDK通常会对API进行错误处理和异常处理，提高了调用的可靠性； 方便快捷：SDK通常提供了示例代码和文档，开发者可以很方便地进行开发和调试； 降低开发成本：使用SDK可以降低开发成本，避免了重复造轮子。 为自定义的接口封装一个SDK的优势（使用自己的SDK） 简化接口调用流程：SDK将复杂的接口调用流程封装起来，用户只需要调用SDK提供的接口方法即可完成接口调用，避免了用户需要了解底层接口实现的复杂性。 提高开发效率：SDK可以提供更友好的API，降低使用接口的门槛，简化开发流程，从而提高开发效率。 提高代码复用率：SDK可以将接口调用相关的代码封装在一起，使得接口调用逻辑可以被多个项目复用，减少重复开发的工作量。 方便版本升级：当接口升级时，只需要修改SDK的实现，而不需要修改使用该接口的所有项目，降低了接口升级的成本。 提高可维护性：封装SDK的过程中，可以将接口调用的异常处理、日志记录等细节封装在一起，使得代码更易于维护。 SDK调用方式的实现原理： 使用SDK调用第三方API的方式通常是通过对应的SDK库来实现的。 SDK库通常封装了API调用的具体实现，包括请求参数的构建、请求的发送和响应的处理等。 调用SDK库需要先进行初始化，通常需要传入API的认证信息、请求地址、端口号等配置信息。 通过调用SDK库提供的API接口，将构建好的请求参数传入，即可完成对第三方API的调用。 SDK调用适用于以下场景： 需要频繁调用第三方API的应用程序，例如支付、短信发送、邮件发送等。 需要简化API调用过程的应用程序，例如通过SDK可以提供更高层次的封装，减少编码量和出错率。 需要快速开发并且集成第三方服务的应用程序，例如SDK可以提供开发文档和示例代码，快速上手并集成第三方服务。 ","date":"2022-12-22T00:00:00Z","image":"https://slothhuman.github.io/img/2.jpg","permalink":"https://slothhuman.github.io/p/api%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F-sdk%E8%B0%83%E7%94%A8/","title":"API调用方式-SDK调用"},{"content":"什么是RPC调用 RPC（Remote Procedure Call）是一种远程过程调用协议，它允许程序在不同的计算机节点之间进行通信和数据交换。简单来说，RPC就是一种能够像调用本地函数一样调用远程函数的协议。\n在分布式系统中，不同的服务通常需要通过网络进行通信，而RPC调用就是为了简化这个过程。通过RPC调用，我们可以像本地调用一样直接调用远程服务中的函数，而无需关心底层网络通信细节。这样可以使得分布式系统的开发更加高效和便捷。\nRPC调用的过程包括请求发送、远程服务调用、响应返回等步骤，其工作流程与本地函数调用类似。RPC调用协议中定义了一些规范，包括消息的格式、传输协议、序列化方式等。这些规范使得不同的RPC框架可以进行通信和交互，从而实现跨语言、跨平台的服务调用。\n适用场景 RPC（Remote Procedure Call）调用方式广泛应用于分布式系统和微服务架构中，特别是在以下场景中：\n高并发、大流量的服务场景。RPC 能够有效地提高系统性能和响应速度，通过将服务请求分散到多个节点上进行并行处理，从而提高了系统的吞吐量和处理能力。 复杂的系统架构。RPC 能够帮助系统将逻辑分离，提高代码复用性，降低系统耦合度。通过使用 RPC，不同的系统组件可以分别部署在不同的服务器上，实现分布式部署和维护。 多语言环境下的服务调用。RPC 能够支持多种编程语言，使得不同的系统组件可以使用不同的编程语言实现，并且无需对外部系统的编程语言进行了解，降低了系统的开发难度和成本。 异构系统集成。RPC 能够实现异构系统之间的数据交换和服务调用，可以将不同的系统组件集成在一起，构建一个高效可靠的系统。 服务治理。RPC 框架通常提供丰富的服务治理功能，如负载均衡、服务注册、熔断机制等，能够帮助系统实现高可用性和容错性，提升系统的稳定性和可靠性。 RPC调用的优势 RPC调用相对于传统的HTTP请求调用，有以下几个优势：\n更高的性能：RPC框架通常采用二进制协议，传输数据量更小，效率更高。而HTTP请求调用采用文本协议，传输数据量较大，效率较低。 更好的扩展性：RPC框架支持多种协议和序列化方式，可以根据实际需要进行灵活选择，更好地适应不同的场景需求。同时，RPC框架通常支持服务发现、负载均衡、容错等功能，可以更方便地进行服务治理。 更强的安全性：RPC框架通常支持加密传输、身份认证等安全机制，可以更好地保障服务调用的安全性。 更好的开发体验：RPC框架通常提供了更方便的服务调用方式，如接口代理、动态代理等，可以更快捷地进行开发。 原理 RPC的基本原理是客户端像调用本地方法一样，通过网络请求远程服务器上的方法，服务器执行方法并返回结果，客户端拿到结果并进行处理。在RPC调用中，远程调用的实现一般分为以下步骤：\n客户端调用本地存根（stub）方法，并将调用的方法和参数封装成消息对象； 客户端向远程服务发起请求，将消息对象发送到远程服务； 服务端接收到请求后，反序列化消息对象，解析出调用的方法和参数； 服务端执行对应的方法，并将返回结果封装成消息对象； 服务端将消息对象序列化后发送给客户端； 客户端接收到消息对象后反序列化，获取返回结果。 RPC的实现原理主要涉及序列化、网络传输、反序列化等技术。序列化是将对象转化成二进制流的过程，网络传输是将序列化后的二进制流进行传输，反序列化则是将二进制流转化成对象的过程。常用的序列化协议有JSON、XML、Hessian、Thrift、Protocol Buffers等，网络传输方式主要有HTTP、TCP、UDP等协议。\n常用的RPC框架 有很多，其中一些比较流行的包括：\ngRPC：由Google开源的高性能RPC框架，基于HTTP/2协议，使用Protocol Buffers作为IDL和序列化工具，支持多种语言。 Dubbo：阿里巴巴开源的分布式服务框架，支持多种协议和序列化方式，提供服务治理和负载均衡等功能。 Thrift：由Facebook开源的跨语言RPC框架，支持多种编程语言，使用自定义IDL和二进制协议进行通信。 gRPC-Web：gRPC的Web版本，支持在Web浏览器中进行gRPC调用。 Spring Cloud：基于Spring框架的微服务框架，包括了众多的子框架，如Eureka、Ribbon、Feign等。 Apache CXF：开源的服务框架，支持多种协议和数据格式，包括SOAP、REST、JSON、XML等。 使用RPC调用自定义接口的步骤 下面我将介绍如何使用 Dubbo 框架来实现 RPC 调用自定义接口的步骤\n步骤如下：\n1.首先需要定义服务接口，即提供哪些方法可以供其他服务调用。在 Dubbo 框架中，可以使用 Java 接口的方式定义服务接口。例如，我们定义一个示例服务接口 HelloService：\n1 2 3 public interface HelloService { String sayHello(String name); } 2.实现服务接口。在 Dubbo 框架中，服务实现类需要实现服务接口中定义的方法。例如，我们实现一个示例服务实现类 HelloServiceImpl：\n1 2 3 4 5 public class HelloServiceImpl implements HelloService { public String sayHello(String name) { return \u0026#34;Hello \u0026#34; + name; } } 3.配置 Dubbo 服务提供者。在 Dubbo 中，服务提供者需要将服务注册到注册中心，并监听指定的端口，等待其他服务的调用。可以通过 XML 配置文件或注解的方式来配置服务提供者。例如，我们使用 XML 配置文件来配置服务提供者：\n1 2 3 4 5 6 7 8 9 \u0026lt;dubbo:application name=\u0026#34;hello-service-provider\u0026#34; /\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://localhost:2181\u0026#34; /\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; port=\u0026#34;20880\u0026#34; /\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;com.example.service.HelloService\u0026#34; ref=\u0026#34;helloService\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;helloService\u0026#34; class=\u0026#34;com.example.service.impl.HelloServiceImpl\u0026#34; /\u0026gt; 其中，dubbo:application 指定服务名称，dubbo:registry 指定注册中心地址，dubbo:protocol 指定协议和端口，dubbo:service 指定服务接口和实现类，ref 指定实现类的实例化对象。\n4.配置 Dubbo 服务消费者。在 Dubbo 中，服务消费者需要从注册中心获取服务提供者的地址，并通过远程调用来调用服务。同样可以通过 XML 配置文件或注解的方式来配置服务消费者。例如，我们使用 XML 配置文件来配置服务消费者：\n1 2 3 4 5 6 7 8 9 \u0026lt;dubbo:application name=\u0026#34;hello-service-consumer\u0026#34; /\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://localhost:2181\u0026#34; /\u0026gt; \u0026lt;dubbo:reference id=\u0026#34;helloService\u0026#34; interface=\u0026#34;com.example.service.HelloService\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;helloController\u0026#34; class=\u0026#34;com.example.controller.HelloController\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;helloService\u0026#34; ref=\u0026#34;helloService\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 其中，dubbo:application 指定服务名称，dubbo:registry 指定注册中心地址，dubbo:reference 指定服务接口，id 指定服务引用的名称，bean 定义消费者 Controller 类，property 注入服务引用。\n5.最后，我们可以在消费者 Controller 类中通过服务引用来调用服务。例如，我们定义一个示例 Controller 类 HelloController：\n1 2 3 4 5 6 7 8 9 @RestController public class HelloController { @Reference private HelloService helloService; @GetMapping(\u0026#34;/hello\u0026#34;) public String sayHello(@RequestParam String name) { return helloService.sayHello(name); } 在上面的示例中，我们使用 @Reference 注解来自动注入 HelloService 接口的实现对象，从而可以直接调用 sayHello 方法来获取服务提供者返回的结果。同时，我们也定义了一个示例的 GET 请求接口 /hello，用于测试服务是否正常运行。\nRPC调用的注意事项及异常处理 当使用 RPC 调用时，需要注意以下几个事项：\n服务接口的定义需要保持一致：在使用 RPC 调用时，服务接口的定义需要在服务提供者和服务消费者之间保持一致，否则会出现调用失败或异常的情况。 服务提供者和消费者的版本需要匹配：在使用 RPC 调用时，服务提供者和服务消费者的版本需要匹配，否则也会出现调用失败或异常的情况。 网络传输的稳定性：RPC 调用依赖于网络传输，在网络不稳定的情况下，会导致调用失败或超时。因此，在实际使用时，需要保证网络传输的稳定性，可以使用负载均衡、重试等机制来提高调用的成功率。 服务端出现异常需要正确处理：在服务提供者出现异常的情况下，需要正确处理异常，避免对整个系统产生影响。可以使用异常处理机制或者日志记录等方式来处理异常。 安全性：由于 RPC 调用是基于网络传输的，因此需要保证传输数据的安全性，可以使用 SSL、加密等方式来保证数据的安全传输。 在 RPC 调用过程中，可能会出现以下几种异常情况：\n调用超时异常：当调用时间超过指定时间时，会抛出调用超时异常，可以通过设置超时时间或调整服务负载来解决。 服务提供者不可用异常：当服务提供者无法正常提供服务时，会抛出服务提供者不可用异常，可以通过检查服务提供者的状态或进行服务降级来解决。 连接异常：当网络连接中断或服务提供者不可用时，会抛出连接异常，可以通过重试机制或检查网络连接状态来解决。 序列化异常：当序列化或反序列化过程中出现异常时，会抛出序列化异常，可以检查数据格式或使用其他序列化方式来解决。 其他异常：在 RPC 调用过程中，还可能出现其他异常，例如服务提供者异常、网络故障等，需要根据具体情况进行处理。 ","date":"2022-12-18T00:00:00Z","image":"https://slothhuman.github.io/img/green.jpg","permalink":"https://slothhuman.github.io/p/rpc%E8%B0%83%E7%94%A8/","title":"RPC调用"},{"content":"HTTP请求工具 HTTP请求工具可以帮助我们方便地发送HTTP请求，并查看响应结果。常见的HTTP请求工具有Postman、Insomnia等，也可以使用编程语言自带的HTTP库或第三方HTTP库进行请求发送。我们这里主要介绍编程语言自带的HTTP库或第三方HTTP库\nJava原生的HttpURLConnection类 HttpURLConnection是Java原生的HTTP客户端库之一，用于实现HTTP连接和请求。它提供了许多可用于控制请求和响应的方法和属性。\nHttpURLConnection支持多种HTTP请求方法，包括GET、POST、PUT、DELETE等，并支持对请求头和请求参数进行自定义配置。此外，它还提供了一些用于获取响应状态码、响应头和响应体等响应信息的方法。\n使用HttpURLConnection发送HTTP请求需要以下步骤：\n创建一个URL对象，该对象表示HTTP请求的URL。 调用URL对象的openConnection()方法打开与URL之间的连接，并将返回一个HttpURLConnection对象。 通过HttpURLConnection对象设置HTTP请求方法、请求头、请求参数等。 调用HttpURLConnection对象的getInputStream()方法获取输入流，用于读取服务器响应。 读取服务器响应，可以使用BufferedReader、InputStreamReader等工具类。 以下是使用HttpURLConnection发送GET请求的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.net.HttpURLConnection; import java.net.URL; import java.io.BufferedReader; import java.io.InputStreamReader; public class HttpUtils { public static String sendGetRequest(String url) throws Exception { HttpURLConnection conn = null; BufferedReader in = null; StringBuilder result = new StringBuilder(); try { URL realUrl = new URL(url); // 打开和URL之间的连接 conn = (HttpURLConnection) realUrl.openConnection(); // 设置请求头 conn.setRequestProperty(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); conn.setRequestMethod(\u0026#34;GET\u0026#34;); // 获取URLConnection对象对应的输入流 in = new BufferedReader(new InputStreamReader(conn.getInputStream(), \u0026#34;UTF-8\u0026#34;)); String line; while ((line = in.readLine()) != null) { result.append(line); } } catch (Exception e) { throw e; } finally { // 关闭资源 if (in != null) { in.close(); } if (conn != null) { conn.disconnect(); } } return result.toString(); } } 上面的代码通过Java的HttpURLConnection类实现了发送GET请求，并且设置了请求头。可以通过调用该工具类中的sendGetRequest()方法发送GET请求。例如：\n1 2 3 4 5 6 7 8 9 10 11 public class Main { public static void main(String[] args) { try { String url = \u0026#34;https://example.com/api\u0026#34;; String response = HttpUtils.sendGetRequest(url); System.out.println(response); } catch (Exception e) { e.printStackTrace(); } } } 在上面的示例代码中，我们调用了sendGetRequest()方法发送了一个GET请求，并将返回的响应输出到控制台。其中，请求URL为https://example.com/api。\nApache HttpClient库 Apache HttpClient是一个流行的Java HTTP客户端库，它提供了比Java原生HttpURLConnection更简单和强大的API，允许您在Java应用程序中以编程方式发送HTTP/HTTPS请求并处理响应。\n下面是使用Apache HttpClient发送HTTP POST请求的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import java.io.IOException; import org.apache.http.HttpEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; public class HttpClientExample { public static void main(String[] args) throws IOException { // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建HttpPost对象 HttpPost httpPost = new HttpPost(\u0026#34;http://example.com/api\u0026#34;); // 设置请求头信息 httpPost.setHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); // 设置请求体内容 String requestBody = \u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;John\\\u0026#34;, \\\u0026#34;age\\\u0026#34;:30}\u0026#34;; StringEntity requestEntity = new StringEntity(requestBody); httpPost.setEntity(requestEntity); // 执行请求 CloseableHttpResponse response = httpClient.execute(httpPost); // 处理响应 try { // 获取响应实体 HttpEntity responseEntity = response.getEntity(); if (responseEntity != null) { String responseString = EntityUtils.toString(responseEntity); System.out.println(responseString); } } finally { response.close(); } } } 上面的代码示例中，我们首先创建一个HttpClient对象，然后创建一个HttpPost对象，并设置请求的URL和请求头信息。接下来，我们将请求体的内容设置为JSON格式的字符串，并将其设置为请求实体。最后，我们执行POST请求，并处理响应。\n在处理响应时，我们首先获取响应实体，然后将其转换为字符串并输出到控制台。最后，我们在finally块中关闭响应对象，以确保资源得到释放。\nApache HttpClient库具有丰富的API和配置选项，使其成为Java应用程序中发送HTTP请求的首选库之一。\nSpring RestTemplate Spring RestTemplate是Spring框架提供的一个基于HTTP的RESTful客户端库，用于在Java应用程序中发送HTTP请求并处理响应。它提供了比Java原生HttpURLConnection更简单和方便的API，允许您以编程方式发送HTTP/HTTPS请求。\n下面是使用Spring RestTemplate发送HTTP POST请求的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import org.springframework.http.HttpEntity; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpMethod; import org.springframework.http.MediaType; import org.springframework.http.ResponseEntity; import org.springframework.util.LinkedMultiValueMap; import org.springframework.util.MultiValueMap; import org.springframework.web.client.RestTemplate; public class RestTemplateExample { public static void main(String[] args) { // 创建RestTemplate对象 RestTemplate restTemplate = new RestTemplate(); // 设置请求头信息 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); // 设置请求体内容 MultiValueMap\u0026lt;String, String\u0026gt; requestBody = new LinkedMultiValueMap\u0026lt;\u0026gt;(); requestBody.add(\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;); requestBody.add(\u0026#34;age\u0026#34;, \u0026#34;30\u0026#34;); // 封装请求头和请求体 HttpEntity\u0026lt;MultiValueMap\u0026lt;String, String\u0026gt;\u0026gt; requestEntity = new HttpEntity\u0026lt;\u0026gt;(requestBody, headers); // 发送POST请求 ResponseEntity\u0026lt;String\u0026gt; responseEntity = restTemplate.exchange(\u0026#34;http://example.com/api\u0026#34;, HttpMethod.POST, requestEntity, String.class); // 获取响应体内容 String responseBody = responseEntity.getBody(); System.out.println(responseBody); } } 在上面的代码示例中，我们首先创建一个RestTemplate对象，然后设置请求头信息和请求体内容。接下来，我们将请求头和请求体封装为HttpEntity对象，并使用exchange()方法发送POST请求。在处理响应时，我们首先获取响应实体，然后将其转换为字符串并输出到控制台。\nSpring RestTemplate类还提供了其他的API，比如getForObject()、postForObject()、postForEntity()等方法，可以方便地发送HTTP请求和处理响应。\n总体而言，Spring RestTemplate是一个易于使用的HTTP客户端库，适用于各种HTTP请求场景。\n使用HTTP请求调用自定义接口的步骤 1.了解自定义接口的URL、请求方法、请求参数等信息。 在使用HTTP请求调用自定义接口之前，需要先了解自定义接口的一些基本信息，包括接口的URL地址、请求方法（GET、POST等）以及请求参数的格式和内容等。\n2.选择合适的HTTP请求工具。 根据项目的需要和自己的习惯，可以选择适合自己的HTTP请求工具。常见的HTTP请求工具包括Java原生的HttpURLConnection类、Apache HttpClient库、Spring RestTemplate类、OkHttp库、Retrofit库等。\n3.根据自定义接口的请求方法，构建HTTP请求对象。 根据自定义接口的请求方法，构建相应的HTTP请求对象，可以使用HTTP请求工具提供的API或者自己手动构建。例如，使用Java原生的HttpURLConnection类，可以通过如下方式构建HTTP请求对象：\n1 2 3 URL url = new URL(\u0026#34;http://www.example.com/api\u0026#34;); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\u0026#34;GET\u0026#34;); 4.设置HTTP请求参数。 根据自定义接口的请求参数格式，设置HTTP请求参数。对于不同的HTTP请求工具，设置HTTP请求参数的方式可能有所不同。以Java原生的HttpURLConnection类为例，可以使用setRequestProperty方法设置HTTP请求头，使用getOutputStream方法向服务器发送请求体参数，例如：\n1 2 3 4 5 6 connection.setRequestProperty(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); String requestBody = \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;John\\\u0026#34;, \\\u0026#34;age\\\u0026#34;: 30}\u0026#34;; OutputStream os = connection.getOutputStream(); os.write(requestBody.getBytes()); os.flush(); os.close(); 5.发送HTTP请求，并等待接口响应。 调用HTTP请求对象的connect方法发送HTTP请求，并等待接口响应。例如，在使用Java原生的HttpURLConnection类发送HTTP请求后，可以通过getInputStream方法获取接口响应：\n1 2 3 connection.connect(); InputStream is = connection.getInputStream(); // 处理接口响应 6.解析HTTP响应，获取响应状态码、响应头、响应体等信息。 根据需要，解析HTTP响应，获取响应状态码、响应头、响应体等信息。对于不同的HTTP请求工具，解析HTTP响应的方式可能有所不同。例如，在使用Java原生的HttpURLConnection类获取HTTP响应后，可以通过getResponseCode方法获取响应状态码：\n1 int statusCode = connection.getResponseCode(); 7.根据业务需求处理接口返回的数据。 根据自定义接口的返回数据格式和业务需求，处理接口返回的数据。例如，在使用Spring RestTemplate类发送HTTP请求后，可以使用getForObject方法获取响应体，并将其转化为Java对象：\n1 2 3 RestTemplate restTemplate = new RestTemplate(); String url = \u0026#34;http://www.example.com/api\u0026#34;; MyObject myObject = restTemplate.getForObject(url, MyObject.class); 一个简单的HTTP请求调用自定义接口的示例 此示例使用的是Java原生的HttpURLConnection类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import java.net.HttpURLConnection; import java.net.URL; import java.io.BufferedReader; import java.io.InputStreamReader; public class HttpExample { public static void main(String[] args) { try { // 创建连接对象 URL url = new URL(\u0026#34;http://your-api-url.com\u0026#34;); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); // 设置请求方法和请求头 conn.setRequestMethod(\u0026#34;POST\u0026#34;); conn.setRequestProperty(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); conn.setRequestProperty(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;); // 设置请求体（可选） String requestBody = \u0026#34;{\\\u0026#34;param1\\\u0026#34;:\\\u0026#34;value1\\\u0026#34;,\\\u0026#34;param2\\\u0026#34;:\\\u0026#34;value2\\\u0026#34;}\u0026#34;; conn.setDoOutput(true); conn.getOutputStream().write(requestBody.getBytes()); // 发起请求并获取响应 int responseCode = conn.getResponseCode(); BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream())); String inputLine; StringBuffer response = new StringBuffer(); while ((inputLine = in.readLine()) != null) { response.append(inputLine); } in.close(); // 处理响应结果 System.out.println(\u0026#34;Response Code : \u0026#34; + responseCode); System.out.println(\u0026#34;Response Body : \u0026#34; + response.toString()); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2022-12-10T00:00:00Z","image":"https://slothhuman.github.io/img/blue.jpg","permalink":"https://slothhuman.github.io/p/%E4%BD%BF%E7%94%A8http%E8%AF%B7%E6%B1%82%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3/","title":"使用HTTP请求调用自定义接口"},{"content":"生产问题 缓存雪崩 概念\n缓存在同一时间大面积失效，后面的请求都直接落到数据库上面，导致数据库短时间承受大量请求 解决方法\n针对Redis服务不可用\n采⽤ Redis 集群，避免单机出现问题整个缓存服务都没办法使⽤。 限流，避免同时处理⼤量的请求 针对热点缓存失效的情况\n设置不同的失效时间⽐如随机设置缓存的失效时间 缓存永不失效 缓存穿透 概念\n大量请求的key不存在于缓存中，导致请求直接到了数据库上面，根本没经过缓存层 解决办法\n做好参数校验\n，不合法的参数请求直接抛异常 缓存无效的key\n如果在缓存和数据库中都查询不到某个key对应的数据，就把这个key加入到缓存中并设置一个比较短的过期时间 布隆过滤器\n先把所有可能存在的请求的值存放在布隆过滤器中，当用户请求过来，先判断是否存在于布隆过滤器中，若存在再去查询缓存 子主题 4\n","date":"2022-11-25T00:00:00Z","image":"https://slothhuman.github.io/img/27.jpg","permalink":"https://slothhuman.github.io/p/redis%E4%BA%94%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/","title":"redis（五）生产问题"},{"content":"简介 当今的应用程序通常需要与其他应用程序或服务进行通信，以实现数据的共享和协作。为了实现这种通信，通常需要使用API（Application Programming Interface）接口，而自定义API接口允许应用程序与其他应用程序或服务进行交互。\n而HTTP请求是应用程序之间最常用的通信方式之一，它允许应用程序通过网络向其他应用程序或服务发送请求，并接收返回的响应，使用HTTP请求可以使应用程序与其他应用程序或服务进行交互，共享数据和资源。\nHTTP请求方法 HTTP请求方法是HTTP协议定义的一组标准方法，用于指示客户端要执行的操作类型。常用的HTTP请求方法包括GET、POST、PUT和DELETE。\nGET 用于从服务器获取资源，通过查询参数传递参数，不会改变服务器状态。通常用于获取数据。\nPOST 用于向服务器提交数据，通过请求体传递参数，可能会改变服务器状态。通常用于提交数据，如表单提交、上传文件等。\nPUT 用于向服务器更新资源，通过请求体传递参数，可能会改变服务器状态。通常用于更新数据，如更新文件、更新文章等。\nDELETE 用于从服务器删除资源，通过查询参数传递参数，可能会改变服务器状态。通常用于删除数据。\n其他方法 除了上述常见的HTTP请求方法，还有一些其他的HTTP请求方法，如OPTIONS、HEAD、PATCH等，但它们使用较少，本文不作过多介绍。\n在使用HTTP请求时，应该根据实际需求选择合适的HTTP请求方法，例如，如果只需要获取数据，应该使用GET方法；如果需要向服务器提交数据，应该使用POST方法；如果需要更新数据，应该使用PUT方法；如果需要删除数据，应该使用DELETE方法。此外还需要根据HTTP规范设置请求头和请求体。\nHTTP请求参数 HTTP请求参数是客户端向服务器传递信息的一种方式，包括查询参数、请求头和请求体。\n查询参数 查询参数是通过URL的查询字符串传递的键值对，使用“?”分隔URL和查询参数，使用“\u0026amp;”连接多个查询参数。\n例如，调用一个获取用户信息的接口，需要传递用户ID和名称两个查询参数：\n1 https://example.com/api/users?id=123\u0026amp;name=John 请求头 请求头是HTTP请求中的一部分，包括各种元数据信息，以键值对的形式表示。常用的请求头包括Content-Type、Authorization、Accept等。例如，以下是使用请求头指定请求体类型的示例：\n1 2 3 4 5 POST /api/users HTTP/1.1 Host: example.com Content-Type: application/json {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:18} 这个示例中，通过POST方法向example.com的/api/users接口提交JSON格式的请求体，使用Content-Type请求头指定请求体类型为application/json。\n请求体 请求体是POST、PUT等方法中发送的数据，用于向服务器提交数据，通常使用JSON或表单数据格式。例如，以下是使用请求体提交表单数据的示例：\n1 2 3 4 5 POST /api/users HTTP/1.1 Host: example.com Content-Type: application/x-www-form-urlencoded name=John\u0026amp;age=18 这个示例中，通过POST方法向example.com的/api/users接口提交表单数据，使用Content-Type请求头指定请求体类型为application/x-www-form-urlencoded。\n在使用HTTP请求时，应该根据实际需求选择合适的HTTP请求参数。例如，如果需要传递一些简单的参数，可以使用查询参数；如果需要传递一些复杂的参数或数据，可以使用请求体；如果需要指定请求的一些元数据信息，可以使用请求头。同时，还应该注意HTTP请求参数的编码方式，避免出现乱码等问题。\nHTTP响应 HTTP响应是服务器返回给客户端的信息，通常包括三个部分：状态行、响应头和响应体。\n状态行 状态行包含三个字段，分别是HTTP版本号、状态码和状态码的原因短语。例如：\n1 HTTP/1.1 200 OK 表示使用HTTP/1.1协议，状态码为200，状态码的原因短语为OK。\n常见的状态码及其含义：\n200 OK：请求成功，服务器返回请求的资源。 301 Moved Permanently：请求的资源已永久移动到新的URI。 302 Found：请求的资源已临时移动到新的URI。 400 Bad Request：请求有语法错误或请求参数不正确。 401 Unauthorized：请求未经授权。 403 Forbidden：请求被服务器拒绝。 404 Not Found：请求的资源未找到。 500 Internal Server Error：服务器内部错误。 响应头 响应头包含一系列键值对，描述了响应的元数据，例如服务器类型、数据格式等。常见的响应头字段及其含义：\nContent-Type：响应的数据类型，例如text/html、application/json等。 Content-Length：响应体的长度。 Server：服务器类型，例如Apache、Nginx等。 Set-Cookie：设置客户端的cookie。 Expires：过期时间，例如Tue, 01 Jan 2030 00:00:00 GMT。 响应头的格式如下：\n1 Key: Value 例如：\n1 2 Content-Type: application/json Server: Apache/2.4.41 (Ubuntu) 响应体 响应体包含了实际的数据内容，例如HTML、JSON等格式的文本数据，或者二进制数据等。\n例如，请求一个返回JSON格式数据的接口，服务器返回的响应体中包含了用户信息：\n1 2 3 4 5 { \u0026#34;id\u0026#34;: 123, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 18 } 在使用HTTP请求时，需要对响应状态码、响应头和响应体进行处理，根据实际需求进行解析和转换。\n","date":"2022-11-20T00:00:00Z","image":"https://slothhuman.github.io/img/purple.jpg","permalink":"https://slothhuman.github.io/p/%E8%AF%A6%E8%A7%A3http%E8%AF%B7%E6%B1%82/","title":"详解HTTP请求"},{"content":"持久化 快照（RDB）（Redis默认的持久化方式） 追加文件（AOF） appendfsync always #每次有数据修改发⽣时都会写⼊AOF⽂件,这样会严重降低Redis的速度 appendfsync everysec #每秒钟同步⼀次，显示地将多个写命令同步到硬盘 appendfsync no #让操作系统决定何时进⾏同步 ","date":"2022-11-18T00:00:00Z","image":"https://slothhuman.github.io/img/26.jpg","permalink":"https://slothhuman.github.io/p/redis%E5%9B%9B%E6%8C%81%E4%B9%85%E5%8C%96/","title":"redis（四）持久化"},{"content":"缓存数据 设置过期时间 有助于缓解内存的消耗 有利于业务场景，有时候某些数据就是只在某个时间段存在 过期删除策略 惰性删除\n使用到这个数据时才进行过期检查，对CPU友好 定期删除\n定期对过期数据进行删除，对内存友好 redis采用两者结合\n数据淘汰策略 volatile-lru（least recently used）\nvolatile-ttl\nvolatile-random\nallkeys-lru（least recently used）（这个是最常⽤的）\nallkeys-random\nno-eviction\nvolatile-lfu（least frequently used）\nallkeys-lfu（least frequently used）\n面试题：MySQL ⾥有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数 据都是热点数据?\n计算数据所占用，设置最大内存空间 选择合适的内存淘汰策略 缓存利用率和一致性问题 提高缓存利用率\n想法：缓存中只保留“热数据”\n1.写请求只写入数据库 2.读请求先读缓存，缓存没有再去读数据库，并重建缓存 3.同时，写入缓存中的数据都设置过期时间 保证缓存与数据库实时一致\n写数据时，不但要更新数据库，同时也更新缓存 如何保证缓存和数据库数据的⼀致性？ 子主题 1 ","date":"2022-11-17T00:00:00Z","image":"https://slothhuman.github.io/img/25.jpg","permalink":"https://slothhuman.github.io/p/redis%E4%B8%89%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE/","title":"redis（三）缓存数据"},{"content":"单线程模型 文件事件处理器 Redis 基于 Reactor 模式来设计开发了⾃⼰的⼀套⾼效的事件处理模型，这套事件处理模型对应的是 Redis 中的⽂件事件处理器（file event handler）。\n多个 socket（客户端连接） IO 多路复⽤程序（⽀持多个客户端连接的关键） ⽂件事件分派器（将 socket 关联到相应的事件处理器） 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器） Redis 通过IO 多路复⽤程序 来监听来⾃客户端的⼤量连接（或者说是监听多个 socket），它会 将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发⽣\nRedis 6.0之前没有使⽤多线程？ 1.单线程编程容易且更容易维护 2.redis性能瓶颈不在CPU，主要在内存和网络 多线程就可能会出现死锁、上下文切换等问题，可能会影响性能 Redis6.0 之后为何引⼊了多线程？ 为了提高网络IO读写功能，但执行命令还是单线程 ","date":"2022-11-15T00:00:00Z","image":"https://slothhuman.github.io/img/24.jpg","permalink":"https://slothhuman.github.io/p/redis%E4%BA%8C%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/","title":"redis（二）单线程模型"},{"content":"数据结构 String 简单动态字符串 保存文本数据、保存二进制数据 获取字符串长度复杂度为O(1) SDS API是安全的，不会造成缓冲区溢出 List 双向链表 hash 数组+链表 set sorted set 增加了⼀个权重参数 score，有序 ","date":"2022-11-13T00:00:00Z","image":"https://slothhuman.github.io/img/23.jpg","permalink":"https://slothhuman.github.io/p/redis%E4%B8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"redis（一）数据结构"},{"content":"简介 在Spring框架中，@RequestParam、@RequestBody、@PathVariable是常用的注解之一。这些注解可以用于控制器（Controller）中的方法参数，方便处理HTTP请求。本文将分别介绍这三个注解的使用方法、原理、代码示例以及它们之间的对比不同。\n@RequestParam注解 使用方法 @RequestParam注解用于将HTTP请求中的参数绑定到控制器方法的参数上。在使用@RequestParam注解时，可以设置参数名、是否必须、默认值等属性。\n示例代码如下：\n1 2 3 4 @GetMapping(\u0026#34;/user\u0026#34;) public User getUser(@RequestParam(\u0026#34;id\u0026#34;) Long id) { return userService.getUserById(id); } 在上面的示例中，@RequestParam注解绑定了请求参数中名为\u0026quot;id\u0026quot;的参数到getUser()方法的id参数上。\n原理 当Spring Boot应用程序接收到一个HTTP请求时，Spring框架将请求参数解析为一个名-值对的映射。在控制器方法上使用@RequestParam注解时，Spring框架会自动将请求参数的值与控制器方法的参数绑定起来。\n代码示例 1 2 3 4 5 6 7 @GetMapping(\u0026#34;/user\u0026#34;) public User getUser(@RequestParam(\u0026#34;id\u0026#34;) Long id, @RequestParam(value = \u0026#34;name\u0026#34;, required = false, defaultValue = \u0026#34;Guest\u0026#34;) String name) { User user = userService.getUserById(id); user.setName(name); return user; } 在上面的示例中，我们使用@RequestParam注解绑定了两个请求参数。\u0026ldquo;id\u0026quot;参数是必须的，而\u0026quot;name\u0026quot;参数是可选的。如果请求中没有传递\u0026quot;name\u0026quot;参数，则默认值为\u0026quot;Guest\u0026rdquo;。\n@RequestBody注解 使用方法 @RequestBody注解用于将HTTP请求体绑定到控制器方法的参数上。在使用@RequestBody注解时，我们需要指定请求体的数据类型。\n示例代码如下：\n1 2 3 4 @PostMapping(\u0026#34;/user\u0026#34;) public User createUser(@RequestBody User user) { return userService.createUser(user); } 在上面的示例中，@RequestBody注解绑定了请求体中的数据到createUser()方法的user参数上。\n原理 当Spring Boot应用程序接收到一个HTTP请求时，Spring框架将请求体解析为一个Java对象。在控制器方法上使用@RequestBody注解时，Spring框架会自动将请求体中的数据绑定到控制器方法的参数上。\n代码示例 1 2 3 4 5 @PostMapping(\u0026#34;/user\u0026#34;) public User createUser(@RequestBody User user) { User savedUser = userService.createUser(user); return savedUser; } 在上面的示例中，我们使用@RequestBody注解绑定了请求体中的数据到User对象上。Spring框架会自动将请求体中的数据解析为一个User对象，并将其绑定到createUser()方法的user参数上。\n@PathVariable注解 使用方法 @PathVariable注解用于将URL中的参数绑定到控制器方法的参数上。在使用@PathVariable注解时，需要在注解中指定URL中的参数名。\n示例代码如下：\n1 2 3 4 @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User getUser(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return userService.getUserById(id); } 在上面的示例中，@PathVariable注解绑定了URL中名为\u0026quot;id\u0026quot;的参数到getUser()方法的id参数上。\n原理 当Spring Boot应用程序接收到一个HTTP请求时，Spring框架将请求URL解析为一个名-值对的映射。在控制器方法上使用@PathVariable注解时，Spring框架会自动将URL中的参数值与控制器方法的参数绑定起来。\n代码示例 1 2 3 4 5 @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User getUser(@PathVariable(\u0026#34;id\u0026#34;) Long id) { User user = userService.getUserById(id); return user; } 在上面的示例中，我们使用@PathVariable注解绑定了URL中的\u0026quot;id\u0026quot;参数到getUser()方法的id参数上。Spring框架会自动将URL中的\u0026quot;id\u0026quot;参数值绑定到id参数上，并调用getUser()方法返回相应的用户对象。\n需要注意的是，@PathVariable注解也可以使用默认值和正则表达式等属性，以适应更多的场景。\n1 2 3 4 5 6 7 @GetMapping(\u0026#34;/user/{id:[\\\\d]+}\u0026#34;) public User getUser(@PathVariable(name = \u0026#34;id\u0026#34;, required = true) Long id, @PathVariable(name = \u0026#34;name\u0026#34;, defaultValue = \u0026#34;Guest\u0026#34;) String name) { User user = userService.getUserById(id); user.setName(name); return user; } 在上面的示例中，我们使用正则表达式指定了\u0026quot;id\u0026quot;参数必须为数字，使用了required属性确保\u0026quot;id\u0026quot;参数必须存在。同时，我们使用了defaultValue属性，以便在\u0026quot;name\u0026quot;参数未指定时使用默认值\u0026quot;Guest\u0026quot;。\n对比不同 @RequestParam和@PathVariable都用于将请求参数绑定到控制器方法的参数上，但是它们的作用方式不同。@RequestParam注解绑定的参数是在请求参数中指定的，而@PathVariable注解绑定的参数是在请求URL中指定的。\n@RequestBody注解用于将HTTP请求中的请求体绑定到方法参数上。请求体可以是JSON、XML、二进制数据等类型，与@RequestParam和@PathVariable不同，@RequestBody注解绑定的参数不是单个值，而是整个请求体。\n综上所述，@RequestParam、@RequestBody、@PathVariable这三个注解在实际应用中各有所用，具体使用哪一个取决于控制器方法所需的参数类型和参数来源。\n","date":"2022-11-09T00:00:00Z","image":"https://slothhuman.github.io/img/yes.jpg","permalink":"https://slothhuman.github.io/p/%E8%AF%A6%E8%A7%A3@requestparam@requestbody@pathvariable/","title":"详解@RequestParam、@RequestBody、@PathVariable"}]